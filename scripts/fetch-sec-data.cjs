#!/usr/bin/env node
/**
 * Standalone SEC EDGAR Data Fetcher for GitHub Actions
 * Fetches bank financial data from SEC EDGAR API and saves to JSON file
 *
 * Features:
 * - Security type identification (common shares vs exchange-traded securities)
 * - Dividend metrics (TTM dividends, dividend payout ratio)
 */

const axios = require('axios');
const fs = require('fs');
const path = require('path');

// Configuration
const CONFIG = {
  edgarUserAgent: process.env.EDGAR_USER_AGENT || 'Bank-Analyzer github-actions@example.com',
  requestDelay: 150, // 150ms = ~6 req/sec (under SEC's 10 req/sec limit)
  // Bank list is now loaded dynamically from bank-list.json (generated by discover-banks.cjs)
  // Falls back to a minimal set if the file doesn't exist yet
  fallbackTickers: ['JPM', 'BAC', 'WFC', 'C', 'USB', 'PNC'],

  /**
   * Patterns to identify exchange-traded securities (preferred stock, debt securities)
   * These are securities that trade on exchanges but are NOT common shares
   *
   * IMPORTANT: Only use separator-based patterns to avoid false positives
   * - Removed /PR[A-Z]$/i - caused false positives (PRK = Park National, BPRN = Princeton Bancorp)
   * - Removed /P$/i - caused false positives (FBP = First BanCorp, TMP = Tompkins Financial)
   *
   * Reliable patterns require explicit separators (hyphen, dot) before the preferred indicator
   */
  exchangeTradedPatterns: [
    /-P[A-Z]?$/i,       // Hyphen + P + optional letter (e.g., BAC-PA, WFC-PB, BANF-P)
    /\.P[A-Z]?$/i,      // Dot + P + optional letter (e.g., BAC.PA, WFC.PB)
    /-PR[A-Z]?$/i,      // Hyphen + PR + optional letter (e.g., BAC-PRA, WFC-PRB)
    /\.PR[A-Z]?$/i,     // Dot + PR + optional letter (e.g., BAC.PRA)
  ],

};

/**
 * Load bank list from generated bank-list.json file
 * This file is produced by discover-banks.cjs which queries SEC EDGAR by SIC code
 */
function loadBankList() {
  const bankListPath = path.join(__dirname, '..', 'public', 'data', 'bank-list.json');

  try {
    if (fs.existsSync(bankListPath)) {
      const data = JSON.parse(fs.readFileSync(bankListPath, 'utf8'));
      const banks = data.banks || [];

      // Filter to only banks with tickers and valid exchanges (NYSE, NASDAQ, OTC)
      const validBanks = banks.filter(b =>
        b.ticker &&
        ['NYSE', 'NASDAQ', 'OTC'].includes(b.exchange)
      );

      console.log(`✓ Loaded ${validBanks.length} banks from bank-list.json`);
      console.log(`  Source: SEC EDGAR + SIC Classification`);
      console.log(`  Generated: ${data.metadata?.generatedAt || 'unknown'}`);

      return validBanks;
    } else {
      console.warn('Warning: bank-list.json not found, using fallback tickers');
      console.warn('Run "node scripts/discover-banks.cjs" to generate the bank list');
      return null;
    }
  } catch (error) {
    console.warn(`Warning: Could not load bank-list.json: ${error.message}`);
    return null;
  }
}

// Global cache for SEC ticker-to-CIK mapping
let tickerToCikMap = null;

// Global set of known base tickers from bank-list.json for cross-reference
// Used to identify if removing a suffix yields a known base ticker (e.g., BANF exists → BANFP is likely preferred)
let knownBaseTickers = new Set();

// Delay helper
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

/**
 * Get prior close stock price from Marketstack API
 * Requires MARKETSTACK_API_KEY environment variable
 * Uses EOD (end-of-day) endpoint for prior close prices
 * Commercial use allowed on Professional plan ($49.99/mo) and above
 * @see https://marketstack.com/documentation
 */
async function getCurrentPrice(ticker) {
  const apiKey = process.env.MARKETSTACK_API_KEY;

  if (!apiKey) {
    console.warn(`  Warning: MARKETSTACK_API_KEY not set, skipping price fetch for ${ticker}`);
    return null;
  }

  try {
    // Using Marketstack EOD endpoint for prior close price
    const url = `http://api.marketstack.com/v1/eod/latest?access_key=${apiKey}&symbols=${ticker}`;
    const response = await axios.get(url, {
      timeout: 15000,
      headers: { 'User-Agent': 'Bank-Analyzer/1.0' }
    });

    // Check for API error
    if (response.data?.error) {
      console.warn(`  Warning: Marketstack API error for ${ticker}: ${response.data.error.message}`);
      return null;
    }

    // Extract close price from the first data entry
    const data = response.data?.data?.[0];
    const price = data?.close;
    return price ? parseFloat(price) : null;
  } catch (error) {
    console.warn(`  Warning: Could not fetch price for ${ticker}: ${error.message}`);
    return null;
  }
}

/**
 * Load SEC's ticker-to-CIK mapping (cached globally)
 */
async function loadTickerToCikMap() {
  if (tickerToCikMap) {
    return tickerToCikMap; // Return cached version
  }

  try {
    console.log('Loading SEC ticker-to-CIK mapping...');
    await delay(CONFIG.requestDelay);

    const response = await axios.get(
      'https://www.sec.gov/files/company_tickers.json',
      {
        headers: { 'User-Agent': CONFIG.edgarUserAgent },
        timeout: 30000
      }
    );

    // Convert array format to ticker-keyed map
    // SEC returns: { "0": { "cik_str": 320193, "ticker": "AAPL", "title": "Apple Inc." }, ... }
    tickerToCikMap = {};

    for (const key in response.data) {
      const company = response.data[key];
      if (company.ticker && company.cik_str) {
        // Store with uppercase ticker as key
        tickerToCikMap[company.ticker.toUpperCase()] = {
          cik: String(company.cik_str).padStart(10, '0'),
          name: company.title
        };
      }
    }

    console.log(`✓ Loaded ${Object.keys(tickerToCikMap).length} company mappings`);
    return tickerToCikMap;
  } catch (error) {
    throw new Error(`Failed to load ticker-to-CIK map: ${error.message}`);
  }
}

/**
 * Get company CIK and info from ticker
 */
async function getCompanyInfo(ticker) {
  try {
    // Load mapping if not already loaded
    const map = await loadTickerToCikMap();

    const upperTicker = ticker.toUpperCase();
    const company = map[upperTicker];

    if (!company) {
      throw new Error(`Ticker ${ticker} not found in SEC database`);
    }

    return {
      cik: company.cik,
      name: company.name
    };
  } catch (error) {
    throw new Error(`Failed to get company info: ${error.message}`);
  }
}

/**
 * Fetch company facts from SEC EDGAR
 */
async function getCompanyFacts(cik) {
  try {
    await delay(CONFIG.requestDelay);

    const paddedCik = cik.padStart(10, '0');
    const url = `https://data.sec.gov/api/xbrl/companyfacts/CIK${paddedCik}.json`;

    const response = await axios.get(url, {
      headers: { 'User-Agent': CONFIG.edgarUserAgent },
      timeout: 30000
    });

    return response.data;
  } catch (error) {
    throw new Error(`Failed to fetch company facts: ${error.message}`);
  }
}

/**
 * Determine security type based on ticker symbol and SEC EDGAR data
 *
 * Security Types:
 * - "common": Common shares (standard equity)
 * - "exchange-traded": Preferred stock, debt securities, or other exchange-traded instruments
 *
 * Classification Logic (in order of priority):
 * 1. Check ticker symbol patterns with separators (-P, .P, -PR, .PR)
 * 2. Cross-reference: Check if removing suffix yields a known base ticker (e.g., BANF exists → BANFP is preferred)
 * 3. SEC EDGAR XBRL: Check for preferred stock-specific concepts in the filings
 * 4. Default to "common" if no indicators found
 *
 * @param {string} ticker - Stock ticker symbol
 * @param {Object} companyFacts - SEC EDGAR company facts data
 * @returns {Object} Security type classification with reasoning
 */
function determineSecurityType(ticker, companyFacts) {
  const upperTicker = ticker?.toUpperCase() || '';
  let securityType = 'common';
  let isExchangeTraded = false;
  let reason = 'default';

  // Check 1: Ticker symbol patterns with explicit separators (most reliable)
  // Only patterns with hyphen or dot separators to avoid false positives
  for (const pattern of CONFIG.exchangeTradedPatterns) {
    if (pattern.test(upperTicker)) {
      securityType = 'exchange-traded';
      isExchangeTraded = true;
      reason = `ticker pattern match: ${pattern}`;
      return { securityType, isExchangeTraded, reason };
    }
  }

  // Check 2: Cross-reference - if ticker ends in P and removing P yields a known base ticker
  // This catches cases like BANFP (BANF is a known common stock) or HBANP (HBAN is known)
  if (upperTicker.endsWith('P') && upperTicker.length > 2) {
    const potentialBase = upperTicker.slice(0, -1);
    if (knownBaseTickers.has(potentialBase)) {
      securityType = 'exchange-traded';
      isExchangeTraded = true;
      reason = `suffix P with known base ticker: ${potentialBase}`;
      return { securityType, isExchangeTraded, reason };
    }
  }

  // Check 3: SEC EDGAR XBRL - Check for preferred stock dividend concepts
  // If the filing reports preferred dividends, this is likely a preferred share ticker
  if (companyFacts) {
    // Check for preferred stock-specific dividend concepts
    // These would only be reported for preferred share tickers, not common stock
    const preferredDividendConcepts = [
      'PreferredStockDividendsPerShareDeclared',
      'PreferredStockDividendsPerShareCashPaid',
      'DividendsPreferredStock',
      'PreferredStockDividendsAndOtherAdjustments'
    ];

    for (const concept of preferredDividendConcepts) {
      const conceptData = companyFacts.facts?.['us-gaap']?.[concept];
      if (conceptData) {
        const units = conceptData.units?.USD || conceptData.units?.['USD/shares'];
        if (units && units.length > 0) {
          // Check if there's recent data (within last 2 years)
          const recentData = units.filter(item => {
            if (!item.end) return false;
            const endDate = new Date(item.end);
            const twoYearsAgo = new Date();
            twoYearsAgo.setFullYear(twoYearsAgo.getFullYear() - 2);
            return endDate >= twoYearsAgo && item.val > 0;
          });

          if (recentData.length > 0) {
            securityType = 'exchange-traded';
            isExchangeTraded = true;
            reason = `SEC EDGAR preferred dividend concept: ${concept}`;
            return { securityType, isExchangeTraded, reason };
          }
        }
      }
    }
  }

  // Default: common stock
  return {
    securityType,
    isExchangeTraded,
    reason
  };
}

/**
 * Extract dividend data from SEC EDGAR company facts
 *
 * Dividend XBRL Concepts (in order of preference):
 * 1. CommonStockDividendsPerShareDeclared - Dividends declared per share
 * 2. CommonStockDividendsPerShareCashPaid - Dividends actually paid per share
 * 3. DividendsCommonStockCash - Total cash dividends on common stock
 * 4. PaymentsOfDividendsCommonStock - Cash outflow for common dividends
 *
 * TTM Calculation:
 * - Sum the last 4 quarters of dividend payments/declarations
 * - For per-share values, use directly; for totals, divide by shares outstanding
 *
 * @param {Object} companyFacts - SEC EDGAR company facts
 * @param {number} sharesOutstanding - Number of shares outstanding (for ratio calculations)
 * @param {number} netIncome - TTM net income (for payout ratio)
 * @param {number} eps - TTM EPS (for payout ratio)
 * @returns {Object} Dividend metrics
 */
function extractDividendMetrics(companyFacts, sharesOutstanding, netIncome, eps) {
  if (!companyFacts) {
    return {
      ttmDividendPerShare: null,
      dividendPayoutRatio: null,
      dividendMethod: null
    };
  }

  // Try to get TTM dividends per share using various XBRL concepts
  // Priority order: declared first (more commonly reported), then cash paid as fallback

  // Method 1: CommonStockDividendsPerShareDeclared (most commonly reported by banks)
  let dps = getTTMValueForDividends(companyFacts, 'CommonStockDividendsPerShareDeclared');

  // Method 2: CommonStockDividendsPerShareCashPaid (fallback if declared not available)
  if (!dps) {
    dps = getTTMValueForDividends(companyFacts, 'CommonStockDividendsPerShareCashPaid');
  }

  // Method 3: Try Dividends (generic concept)
  if (!dps) {
    dps = getTTMValueForDividends(companyFacts, 'Dividends');
  }

  // If we have per-share dividend data
  let ttmDividendPerShare = null;
  let dividendPayoutRatio = null;
  let dividendMethod = null;

  if (dps && dps.value !== null && dps.value !== undefined) {
    ttmDividendPerShare = dps.value;
    dividendMethod = dps.method || 'per-share';

    // Calculate dividend payout ratio
    // Payout Ratio = DPS / EPS (or Total Dividends / Net Income)
    if (eps && eps > 0) {
      dividendPayoutRatio = (ttmDividendPerShare / eps) * 100;
    }
  } else {
    // Method 4: Try total dividend payments and divide by shares
    const totalDividends = getTTMValueForDividends(companyFacts, 'PaymentsOfDividendsCommonStock') ||
                          getTTMValueForDividends(companyFacts, 'DividendsCash') ||
                          getTTMValueForDividends(companyFacts, 'PaymentsOfDividends');

    if (totalDividends && totalDividends.value && sharesOutstanding) {
      ttmDividendPerShare = totalDividends.value / sharesOutstanding;
      dividendMethod = 'total-divided-by-shares';

      // Calculate payout ratio using total dividends / net income
      if (netIncome && netIncome > 0) {
        dividendPayoutRatio = (totalDividends.value / netIncome) * 100;
      }
    }
  }

  return {
    ttmDividendPerShare: ttmDividendPerShare ? parseFloat(ttmDividendPerShare.toFixed(4)) : null,
    dividendPayoutRatio: dividendPayoutRatio ? parseFloat(dividendPayoutRatio.toFixed(2)) : null,
    dividendMethod
  };
}

/**
 * Get TTM value specifically for dividend-related concepts
 * Similar to getTTMValue but handles per-share values differently (no division needed)
 *
 * @param {Object} companyFacts - Company facts data
 * @param {string} concept - XBRL concept name
 * @returns {Object|null} TTM value with method
 */
function getTTMValueForDividends(companyFacts, concept) {
  try {
    const conceptData = companyFacts.facts?.['us-gaap']?.[concept];
    if (!conceptData) return null;

    // Check for USD values first (for total amounts)
    let units = conceptData.units?.USD;

    // If no USD, check for USD/shares (for per-share values)
    if (!units || units.length === 0) {
      units = conceptData.units?.['USD/shares'];
    }

    if (!units || units.length === 0) return null;

    // Filter for annual and quarterly data
    const annualData = units
      .filter(item => item.form === '10-K' && item.val !== undefined && item.end)
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    const quarterlyData = units
      .filter(item => item.form === '10-Q' && item.val !== undefined && item.end && item.fp)
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    // If annual is most recent, use it
    const mostRecentAnnualDate = annualData.length > 0 ? new Date(annualData[0].end) : null;
    const mostRecentQuarterlyDate = quarterlyData.length > 0 ? new Date(quarterlyData[0].end) : null;

    if (mostRecentAnnualDate && (!mostRecentQuarterlyDate || mostRecentAnnualDate >= mostRecentQuarterlyDate)) {
      return {
        value: annualData[0].val,
        date: annualData[0].end,
        method: 'annual'
      };
    }

    // Try to sum quarters
    if (quarterlyData.length >= 4) {
      const last4Q = quarterlyData.slice(0, 4);
      const ttmValue = last4Q.reduce((sum, q) => sum + (q.val || 0), 0);
      return {
        value: ttmValue,
        date: last4Q[0].end,
        method: 'sum-4Q'
      };
    }

    // Fallback to annual if available
    if (annualData.length > 0) {
      return {
        value: annualData[0].val,
        date: annualData[0].end,
        method: 'annual-fallback'
      };
    }

    return null;
  } catch (error) {
    return null;
  }
}

/**
 * Get latest point-in-time value (for balance sheet items like Assets, Equity)
 *
 * @param {Object} companyFacts - SEC EDGAR company facts
 * @param {string} concept - XBRL concept name
 * @param {string} taxonomy - XBRL taxonomy (default: 'us-gaap')
 * @param {string} unitType - Unit type to look for: 'USD', 'shares', or 'USD/shares' (default: 'USD')
 */
function getLatestPointInTimeValue(companyFacts, concept, taxonomy = 'us-gaap', unitType = 'USD') {
  try {
    const conceptData = companyFacts.facts?.[taxonomy]?.[concept];
    if (!conceptData) return null;

    // Get units based on the specified unit type
    const units = conceptData.units?.[unitType];
    if (!units || units.length === 0) return null;

    // Get most recent value (from either 10-K or 10-Q)
    const allData = units
      .filter(item => (item.form === '10-K' || item.form === '10-Q') && item.val && item.end)
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    if (allData.length > 0) {
      return {
        value: allData[0].val,
        date: allData[0].end,
        form: allData[0].form
      };
    }

    return null;
  } catch (error) {
    return null;
  }
}

/**
 * Get latest two point-in-time values for calculating averages (e.g., average assets)
 * Returns current and prior period values
 *
 * @param {Object} companyFacts - SEC EDGAR company facts
 * @param {string} concept - XBRL concept name
 * @param {string} taxonomy - XBRL taxonomy (default: 'us-gaap')
 * @param {string} unitType - Unit type to look for: 'USD', 'shares', or 'USD/shares' (default: 'USD')
 */
function getLatestTwoPointInTimeValues(companyFacts, concept, taxonomy = 'us-gaap', unitType = 'USD') {
  try {
    const conceptData = companyFacts.facts?.[taxonomy]?.[concept];
    if (!conceptData) return null;

    // Get units based on the specified unit type
    const units = conceptData.units?.[unitType];
    if (!units || units.length === 0) return null;

    // Get all values sorted by date (most recent first)
    const allData = units
      .filter(item => (item.form === '10-K' || item.form === '10-Q') && item.val && item.end)
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    if (allData.length >= 2) {
      return {
        current: {
          value: allData[0].val,
          date: allData[0].end,
          form: allData[0].form
        },
        prior: {
          value: allData[1].val,
          date: allData[1].end,
          form: allData[1].form
        }
      };
    } else if (allData.length === 1) {
      // Only one value available, use it for both (average = current)
      return {
        current: {
          value: allData[0].val,
          date: allData[0].end,
          form: allData[0].form
        },
        prior: null
      };
    }

    return null;
  } catch (error) {
    return null;
  }
}

/**
 * Get TTM (Trailing Twelve Months) value for period-based items like Net Income, EPS
 * Always starts from the most recent filing period (10-K or 10-Q) to show the most current data.
 *
 * Logic:
 * - If most recent filing is a 10-K: Use it directly (it's already a full year / TTM)
 * - If most recent filing is a 10-Q: Calculate TTM by summing the last 4 quarters
 *   - Q1, Q2, Q3 come from 10-Q filings
 *   - Q4 is derived from: Annual (10-K) value - Q1 - Q2 - Q3 of that fiscal year
 *
 * @param {Object} companyFacts - SEC EDGAR company facts
 * @param {string} concept - XBRL concept name
 * @param {string} taxonomy - XBRL taxonomy (default: 'us-gaap')
 * @param {string} unitType - Unit type to look for: 'USD', 'shares', or 'USD/shares' (default: 'USD')
 */
function getTTMValue(companyFacts, concept, taxonomy = 'us-gaap', unitType = 'USD') {
  try {
    const conceptData = companyFacts.facts?.[taxonomy]?.[concept];
    if (!conceptData) return null;

    // Get units based on the specified unit type
    const units = conceptData.units?.[unitType];
    if (!units || units.length === 0) return null;

    // Get all annual data (10-K filings)
    const annualData = units
      .filter(item => item.form === '10-K' && item.val !== undefined && item.val !== null && item.end && item.fy)
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    // Get all quarterly data (10-Q filings with Q1, Q2, Q3 periods)
    const quarterlyData = units
      .filter(item =>
        item.form === '10-Q' &&
        item.val !== undefined && item.val !== null &&
        item.end &&
        item.fy &&
        item.fp &&
        ['Q1', 'Q2', 'Q3'].includes(item.fp) // Only Q1-Q3 from 10-Q filings
      )
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    // Determine the most recent filing date
    const mostRecentAnnualDate = annualData.length > 0 ? new Date(annualData[0].end) : null;
    const mostRecentQuarterlyDate = quarterlyData.length > 0 ? new Date(quarterlyData[0].end) : null;

    // Case 1: No data at all
    if (!mostRecentAnnualDate && !mostRecentQuarterlyDate) {
      return null;
    }

    // Case 2: Only annual data available, or 10-K is more recent than any 10-Q
    if (mostRecentAnnualDate && (!mostRecentQuarterlyDate || mostRecentAnnualDate >= mostRecentQuarterlyDate)) {
      return {
        value: annualData[0].val,
        date: annualData[0].end,
        form: '10-K',
        method: 'annual'
      };
    }

    // Case 3: 10-Q is more recent - calculate TTM from quarters
    // We need to build a list of all quarters including derived Q4 values

    // Build a map of quarterly values by fiscal year and period
    const quarterMap = new Map(); // Key: "YYYY-Q#", Value: { value, end, fy, fp, source }

    // Add Q1, Q2, Q3 from 10-Q filings
    for (const q of quarterlyData) {
      const key = `${q.fy}-${q.fp}`;
      if (!quarterMap.has(key)) {
        quarterMap.set(key, {
          value: q.val,
          end: q.end,
          fy: q.fy,
          fp: q.fp,
          source: '10-Q'
        });
      }
    }

    // Derive Q4 values from annual data
    // Q4 = Annual - Q1 - Q2 - Q3 for the same fiscal year
    for (const annual of annualData) {
      const fy = annual.fy;
      const q1Key = `${fy}-Q1`;
      const q2Key = `${fy}-Q2`;
      const q3Key = `${fy}-Q3`;
      const q4Key = `${fy}-Q4`;

      // Only derive Q4 if we don't already have it and have the annual value
      if (!quarterMap.has(q4Key)) {
        const q1 = quarterMap.get(q1Key);
        const q2 = quarterMap.get(q2Key);
        const q3 = quarterMap.get(q3Key);

        if (q1 && q2 && q3) {
          // Derive Q4 from annual minus Q1-Q3
          const q4Value = annual.val - q1.value - q2.value - q3.value;
          quarterMap.set(q4Key, {
            value: q4Value,
            end: annual.end, // Use annual end date for Q4
            fy: fy,
            fp: 'Q4',
            source: 'derived'
          });
        } else {
          // If we don't have all quarters, use the annual value as Q4 approximation
          // This handles cases where we might be missing some Q data
          quarterMap.set(q4Key, {
            value: annual.val, // Use full annual as placeholder (not ideal but better than nothing)
            end: annual.end,
            fy: fy,
            fp: 'Q4',
            source: '10-K-fallback'
          });
        }
      }
    }

    // Convert map to sorted array (most recent first)
    const allQuarters = Array.from(quarterMap.values())
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    if (allQuarters.length >= 4) {
      // Sum the last 4 quarters to get TTM
      const last4Quarters = allQuarters.slice(0, 4);
      const ttmValue = last4Quarters.reduce((sum, q) => sum + q.value, 0);

      return {
        value: ttmValue,
        date: last4Quarters[0].end, // Most recent quarter end date
        form: '10-Q',
        method: 'sum-4Q',
        quarters: last4Quarters.map(q => ({
          end: q.end,
          period: q.fp,
          value: q.value,
          source: q.source
        }))
      };
    }

    // Fallback: If we have the most recent annual data, use it
    if (annualData.length > 0) {
      console.warn(`  Warning: Using annual data as fallback for ${concept} (insufficient quarterly data)`);
      return {
        value: annualData[0].val,
        date: annualData[0].end,
        form: '10-K',
        method: 'annual-fallback'
      };
    }

    // Last resort: Use whatever quarterly data we have
    if (allQuarters.length > 0) {
      console.warn(`  Warning: Using partial quarterly data for ${concept} (only ${allQuarters.length} quarters available)`);
      const partialTTM = allQuarters.reduce((sum, q) => sum + q.value, 0);
      return {
        value: partialTTM,
        date: allQuarters[0].end,
        form: '10-Q',
        method: `partial-${allQuarters.length}Q`,
        quarters: allQuarters.map(q => ({
          end: q.end,
          period: q.fp,
          value: q.value,
          source: q.source
        }))
      };
    }

    return null;
  } catch (error) {
    return null;
  }
}

/**
 * Calculate all banking metrics using TTM for period-based items
 *
 * @param {Object} companyFacts - SEC EDGAR company facts data
 * @param {number} currentPrice - Current stock price
 * @param {boolean} isExchangeTraded - If true, null out price-related metrics
 * @returns {Object} Calculated financial metrics
 */
function calculateMetrics(companyFacts, currentPrice, isExchangeTraded = false) {
  // Balance sheet items (point-in-time) - use latest value
  const totalAssets = getLatestPointInTimeValue(companyFacts, 'Assets');
  const totalEquity = getLatestPointInTimeValue(companyFacts, 'StockholdersEquity') ||
                      getLatestPointInTimeValue(companyFacts, 'StockholdersEquityIncludingPortionAttributableToNoncontrollingInterest');
  // Note: Share counts use 'shares' unit, not 'USD'
  // Priority: actual shares outstanding first, then DEI taxonomy, then weighted average as last resort
  const sharesOutstanding = getLatestPointInTimeValue(companyFacts, 'CommonStockSharesOutstanding', 'us-gaap', 'shares') ||
                            getLatestPointInTimeValue(companyFacts, 'EntityCommonStockSharesOutstanding', 'dei', 'shares') ||
                            getLatestPointInTimeValue(companyFacts, 'WeightedAverageNumberOfSharesOutstandingBasic', 'us-gaap', 'shares') ||
                            getLatestPointInTimeValue(companyFacts, 'WeightedAverageNumberOfDilutedSharesOutstanding', 'us-gaap', 'shares');
  const goodwill = getLatestPointInTimeValue(companyFacts, 'Goodwill');
  const intangibleAssets = getLatestPointInTimeValue(companyFacts, 'IntangibleAssetsNetExcludingGoodwill');

  // Preferred stock for tangible common equity calculation
  const preferredStock = getLatestPointInTimeValue(companyFacts, 'PreferredStockValue') ||
                         getLatestPointInTimeValue(companyFacts, 'PreferredStockValueOutstanding');

  // Get two periods of assets for average assets calculation (ROAA)
  const assetsForAverage = getLatestTwoPointInTimeValues(companyFacts, 'Assets');

  // ============================================================================
  // BANK-SPECIFIC BALANCE SHEET ITEMS
  // ============================================================================

  // Loans and Leases (for Loans/Assets, Loans/Deposits, ACL/Loans, Provision/Loans)
  const loans = getLatestPointInTimeValue(companyFacts, 'LoansAndLeasesReceivableNetReportedAmount') ||
                getLatestPointInTimeValue(companyFacts, 'FinancingReceivableExcludingAccruedInterestAfterAllowanceForCreditLoss') ||
                getLatestPointInTimeValue(companyFacts, 'NotesReceivableNet') ||
                getLatestPointInTimeValue(companyFacts, 'LoansAndLeasesReceivableNetOfDeferredIncome');

  // Get two periods of loans for average loans calculation (Provision/Avg Loans)
  const loansForAverage = getLatestTwoPointInTimeValues(companyFacts, 'LoansAndLeasesReceivableNetReportedAmount') ||
                          getLatestTwoPointInTimeValues(companyFacts, 'FinancingReceivableExcludingAccruedInterestAfterAllowanceForCreditLoss') ||
                          getLatestTwoPointInTimeValues(companyFacts, 'NotesReceivableNet');

  // Deposits (for Deposits/Assets, Loans/Deposits)
  const deposits = getLatestPointInTimeValue(companyFacts, 'Deposits') ||
                   getLatestPointInTimeValue(companyFacts, 'DepositsDomestic');

  // Allowance for Credit Losses (for ACL/Loans ratio)
  // Note: Removed AllowanceForLoanAndLeaseLossesRealEstate as it only covers real estate loans
  const allowanceForCreditLosses = getLatestPointInTimeValue(companyFacts, 'FinancingReceivableAllowanceForCreditLosses') ||
                                   getLatestPointInTimeValue(companyFacts, 'LoansAndLeasesReceivableAllowance') ||
                                   getLatestPointInTimeValue(companyFacts, 'FinancingReceivableAllowanceForCreditLossExcludingAccruedInterest') ||
                                   getLatestPointInTimeValue(companyFacts, 'AllowanceForDoubtfulAccountsReceivable');

  // Cash and Securities (for Cash & Securities/Assets)
  const cashAndEquivalents = getLatestPointInTimeValue(companyFacts, 'CashAndCashEquivalentsAtCarryingValue') ||
                             getLatestPointInTimeValue(companyFacts, 'CashAndDueFromBanks') ||
                             getLatestPointInTimeValue(companyFacts, 'Cash');
  // Additional bank liquidity: interest-bearing deposits at other banks
  const depositsAtBanks = getLatestPointInTimeValue(companyFacts, 'InterestBearingDepositsInBanks') ||
                          getLatestPointInTimeValue(companyFacts, 'DepositsInBanks');
  // Federal funds sold and securities purchased under agreements to resell
  const fedFundsSold = getLatestPointInTimeValue(companyFacts, 'FederalFundsSoldAndSecuritiesPurchasedUnderAgreementsToResell') ||
                       getLatestPointInTimeValue(companyFacts, 'FederalFundsSold');
  const afsSecurities = getLatestPointInTimeValue(companyFacts, 'AvailableForSaleSecuritiesDebtSecurities') ||
                        getLatestPointInTimeValue(companyFacts, 'AvailableForSaleSecurities') ||
                        getLatestPointInTimeValue(companyFacts, 'AvailableForSaleSecuritiesDebtSecuritiesCurrent');
  const htmSecurities = getLatestPointInTimeValue(companyFacts, 'HeldToMaturitySecurities') ||
                        getLatestPointInTimeValue(companyFacts, 'HeldToMaturitySecuritiesAmortizedCostAfterAllowanceForCreditLoss') ||
                        getLatestPointInTimeValue(companyFacts, 'HeldToMaturitySecuritiesFairValue');

  // ============================================================================
  // BANK-SPECIFIC INCOME STATEMENT ITEMS (TTM)
  // ============================================================================

  // Net Interest Income (for Efficiency Ratio)
  // Note: Do NOT use InterestIncomeExpenseAfterProvisionForLoanLoss as it has provisions deducted
  const netInterestIncome = getTTMValue(companyFacts, 'InterestIncomeExpenseNet') ||
                            getTTMValue(companyFacts, 'NetInterestIncome');

  // Noninterest Income (for Efficiency Ratio)
  // Note: Do NOT use RevenuesNetOfInterestExpense as it includes net interest income (causes double-counting)
  const noninterestIncome = getTTMValue(companyFacts, 'NoninterestIncome') ||
                            getTTMValue(companyFacts, 'FeesAndCommissions');

  // Noninterest Expense (for Efficiency Ratio)
  const noninterestExpense = getTTMValue(companyFacts, 'NoninterestExpense') ||
                             getTTMValue(companyFacts, 'OtherCostAndExpenseOperating') ||
                             getTTMValue(companyFacts, 'OperatingExpenses');

  // Provision for Credit Losses (for Provision/Avg Loans)
  const provisionForCreditLosses = getTTMValue(companyFacts, 'ProvisionForLoanLeaseAndOtherLosses') ||
                                   getTTMValue(companyFacts, 'ProvisionForLoanAndLeaseLosses') ||
                                   getTTMValue(companyFacts, 'ProvisionForCreditLosses') ||
                                   getTTMValue(companyFacts, 'ProvisionForLoanLossesExpensed');

  // Income statement items (period-based) - use TTM
  const netIncome = getTTMValue(companyFacts, 'NetIncomeLoss') ||
                    getTTMValue(companyFacts, 'ProfitLoss') ||
                    getTTMValue(companyFacts, 'NetIncomeLossAvailableToCommonStockholdersBasic');
  // Note: EPS uses 'USD/shares' unit, not 'USD'
  const eps = getTTMValue(companyFacts, 'EarningsPerShareBasic', 'us-gaap', 'USD/shares') ||
              getTTMValue(companyFacts, 'EarningsPerShareDiluted', 'us-gaap', 'USD/shares');

  // Determine most recent data date
  const dataDate = netIncome?.date || totalEquity?.date || totalAssets?.date;

  // Check if data is stale (before 2024)
  const isStale = dataDate ? new Date(dataDate) < new Date('2024-01-01') : false;

  // Log TTM calculation method for debugging
  if (netIncome?.method) {
    console.log(`  Net Income TTM: ${netIncome.method} (${netIncome.form}) as of ${netIncome.date}`);
    if (netIncome.quarters && netIncome.quarters.length > 0) {
      console.log(`    Quarters used: ${netIncome.quarters.map(q => `${q.period}(${q.source})`).join(', ')}`);
    }
  }
  if (eps?.method) {
    console.log(`  EPS TTM: ${eps.method} (${eps.form}) as of ${eps.date}`);
  }

  // Extract dividend metrics
  // Note: Dividends are null for exchange-traded securities (non-common shares)
  const dividendMetrics = isExchangeTraded ? {
    ttmDividendPerShare: null,
    dividendPayoutRatio: null,
    dividendMethod: null
  } : extractDividendMetrics(
    companyFacts,
    sharesOutstanding?.value,
    netIncome?.value,
    eps?.value
  );

  if (dividendMetrics.ttmDividendPerShare !== null) {
    console.log(`  TTM Dividend: $${dividendMetrics.ttmDividendPerShare.toFixed(4)} (${dividendMetrics.dividendMethod})`);
    if (dividendMetrics.dividendPayoutRatio !== null) {
      console.log(`  Dividend Payout Ratio: ${dividendMetrics.dividendPayoutRatio.toFixed(1)}%`);
    }
  }

  // Calculate derived values
  const tangibleBookValue = totalEquity?.value ?
    totalEquity.value - (goodwill?.value || 0) - (intangibleAssets?.value || 0) : null;

  // Tangible Common Equity = Total Equity - Preferred Stock - Goodwill - Intangible Assets
  const tangibleCommonEquity = totalEquity?.value ?
    totalEquity.value - (preferredStock?.value || 0) - (goodwill?.value || 0) - (intangibleAssets?.value || 0) : null;

  // Tangible Assets = Total Assets - Goodwill - Intangible Assets
  const tangibleAssets = totalAssets?.value ?
    totalAssets.value - (goodwill?.value || 0) - (intangibleAssets?.value || 0) : null;

  // Average Assets for ROAA calculation
  const averageAssets = assetsForAverage?.current?.value && assetsForAverage?.prior?.value ?
    (assetsForAverage.current.value + assetsForAverage.prior.value) / 2 :
    (assetsForAverage?.current?.value || null);

  const marketCap = currentPrice && sharesOutstanding?.value ?
    currentPrice * sharesOutstanding.value : null;

  const bookValuePerShare = totalEquity?.value && sharesOutstanding?.value ?
    totalEquity.value / sharesOutstanding.value : null;

  // TBVPS uses Tangible Common Equity (excludes preferred stock) for common shareholders
  const tangibleBookValuePerShare = tangibleCommonEquity && sharesOutstanding?.value ?
    tangibleCommonEquity / sharesOutstanding.value : null;

  // Calculate ratios
  const pni = marketCap && netIncome?.value && netIncome.value > 0 ?
    marketCap / netIncome.value : null;

  const ptbvps = currentPrice && tangibleBookValuePerShare && tangibleBookValuePerShare > 0 ?
    currentPrice / tangibleBookValuePerShare : null;

  const mktCapSE = marketCap && totalEquity?.value && totalEquity.value > 0 ?
    marketCap / totalEquity.value : null;

  const niTBV = netIncome?.value && tangibleBookValue && tangibleBookValue > 0 ?
    netIncome.value / tangibleBookValue : null;

  // ROE = Net Income / Total Equity
  const roe = netIncome?.value && totalEquity?.value && totalEquity.value > 0 ?
    (netIncome.value / totalEquity.value) * 100 : null;

  // Return on Tangible Assets = Net Income / Tangible Assets
  // (Tangible Assets = Total Assets - Goodwill - Intangible Assets)
  const rota = netIncome?.value && tangibleAssets && tangibleAssets > 0 ?
    (netIncome.value / tangibleAssets) * 100 : null;

  // Return on Average Assets (ROAA) = Net Income / Average Total Assets
  const roaa = netIncome?.value && averageAssets && averageAssets > 0 ?
    (netIncome.value / averageAssets) * 100 : null;

  // Return on Tangible Common Equity (ROTCE) = Net Income / Tangible Common Equity
  const rotce = netIncome?.value && tangibleCommonEquity && tangibleCommonEquity > 0 ?
    (netIncome.value / tangibleCommonEquity) * 100 : null;

  // Graham metrics
  const grahamNumber = eps?.value && bookValuePerShare && eps.value > 0 && bookValuePerShare > 0 ?
    Math.sqrt(22.5 * eps.value * bookValuePerShare) : null;

  const grahamMoS = grahamNumber && currentPrice ?
    grahamNumber - currentPrice : null;

  const grahamMoSPct = grahamNumber && currentPrice && currentPrice > 0 ?
    ((grahamNumber - currentPrice) / currentPrice) * 100 : null;

  // ============================================================================
  // NEW BANK-SPECIFIC RATIOS
  // ============================================================================

  // 1. Efficiency Ratio = Noninterest Expense / (Net Interest Income + Noninterest Income)
  // Lower is better - measures operational efficiency. Typical range: 50-70%
  const totalRevenue = (netInterestIncome?.value || 0) + (noninterestIncome?.value || 0);
  const efficiencyRatio = noninterestExpense?.value && totalRevenue > 0 ?
    (noninterestExpense.value / totalRevenue) * 100 : null;

  // 2. ACL/Loans = Allowance for Credit Losses / Total Loans
  // Credit loss reserve as percentage of loan portfolio. Typical range: 1-2%
  const aclToLoans = allowanceForCreditLosses?.value && loans?.value && loans.value > 0 ?
    (allowanceForCreditLosses.value / loans.value) * 100 : null;

  // 3. Provision/Avg Loans = Provision for Credit Losses / Average Loans
  // Annual provision expense as percentage of average loans. Typical range: 0.1-0.5%
  const averageLoans = loansForAverage?.current?.value && loansForAverage?.prior?.value ?
    (loansForAverage.current.value + loansForAverage.prior.value) / 2 :
    (loansForAverage?.current?.value || loans?.value || null);
  const provisionToAvgLoans = provisionForCreditLosses?.value && averageLoans && averageLoans > 0 ?
    (provisionForCreditLosses.value / averageLoans) * 100 : null;

  // 4. Loans/Assets = Total Loans / Total Assets
  // Loan concentration ratio. Typical range: 60-75%
  const loansToAssets = loans?.value && totalAssets?.value && totalAssets.value > 0 ?
    (loans.value / totalAssets.value) * 100 : null;

  // 5. Deposits/Assets = Deposits / Total Assets
  // Funding reliance on deposits. Typical range: 70-85%
  const depositsToAssets = deposits?.value && totalAssets?.value && totalAssets.value > 0 ?
    (deposits.value / totalAssets.value) * 100 : null;

  // 6. Loans/Deposits = Total Loans / Total Deposits
  // Loan-to-deposit ratio (LDR). Typical range: 80-100%
  const loansToDeposits = loans?.value && deposits?.value && deposits.value > 0 ?
    (loans.value / deposits.value) * 100 : null;

  // 7. Cash & Securities/Assets = (Cash + Deposits at Banks + Fed Funds Sold + AFS + HTM) / Total Assets
  // Liquidity position. Typical range: 15-30%
  const cashAndSecurities = (cashAndEquivalents?.value || 0) +
                            (depositsAtBanks?.value || 0) +
                            (fedFundsSold?.value || 0) +
                            (afsSecurities?.value || 0) +
                            (htmSecurities?.value || 0);
  const cashSecuritiesToAssets = totalAssets?.value && totalAssets.value > 0 && cashAndSecurities > 0 ?
    (cashAndSecurities / totalAssets.value) * 100 : null;

  // 8. Equity/Assets = Stockholders' Equity / Total Assets
  // Leverage ratio (higher = less leveraged). Typical range: 8-12%
  const equityToAssets = totalEquity?.value && totalAssets?.value && totalAssets.value > 0 ?
    (totalEquity.value / totalAssets.value) * 100 : null;

  // 9. TCE/TA = Tangible Common Equity / Tangible Assets
  // More conservative capital ratio. Typical range: 6-10%
  const tceToTa = tangibleCommonEquity && tangibleAssets && tangibleAssets > 0 ?
    (tangibleCommonEquity / tangibleAssets) * 100 : null;

  // For exchange-traded securities (preferred, debt), null out price-related metrics
  // These metrics don't apply to non-common shares
  if (isExchangeTraded) {
    return {
      price: null,
      marketCap: null,
      pni: null,
      ptbvps: null,
      mktCapSE: null,
      niTBV: niTBV ? parseFloat(niTBV.toFixed(4)) : null, // Keep non-price metrics
      roe: roe ? parseFloat(roe.toFixed(4)) : null,
      rota: rota ? parseFloat(rota.toFixed(4)) : null,
      roaa: roaa ? parseFloat(roaa.toFixed(4)) : null,
      rotce: rotce ? parseFloat(rotce.toFixed(4)) : null,
      bvps: null,
      tbvps: null,
      grahamNum: null,
      grahamMoS: null,
      grahamMoSPct: null,
      // Dividend metrics null for exchange-traded securities
      ttmDividendPerShare: null,
      dividendPayoutRatio: null,
      dividendMethod: null,
      // Bank-specific ratios (keep for exchange-traded since they're fundamental metrics)
      efficiencyRatio: efficiencyRatio ? parseFloat(efficiencyRatio.toFixed(2)) : null,
      aclToLoans: aclToLoans ? parseFloat(aclToLoans.toFixed(2)) : null,
      provisionToAvgLoans: provisionToAvgLoans ? parseFloat(provisionToAvgLoans.toFixed(2)) : null,
      loansToAssets: loansToAssets ? parseFloat(loansToAssets.toFixed(2)) : null,
      depositsToAssets: depositsToAssets ? parseFloat(depositsToAssets.toFixed(2)) : null,
      loansToDeposits: loansToDeposits ? parseFloat(loansToDeposits.toFixed(2)) : null,
      cashSecuritiesToAssets: cashSecuritiesToAssets ? parseFloat(cashSecuritiesToAssets.toFixed(2)) : null,
      equityToAssets: equityToAssets ? parseFloat(equityToAssets.toFixed(2)) : null,
      tceToTa: tceToTa ? parseFloat(tceToTa.toFixed(2)) : null,
      dataDate: dataDate,
      isStale: isStale,
      ttmMethod: netIncome?.method || 'unknown'
    };
  }

  return {
    price: currentPrice,
    marketCap: marketCap ? marketCap / 1000000 : null, // Convert to millions
    pni: pni ? parseFloat(pni.toFixed(4)) : null,
    ptbvps: ptbvps ? parseFloat(ptbvps.toFixed(4)) : null,
    mktCapSE: mktCapSE ? parseFloat(mktCapSE.toFixed(4)) : null,
    niTBV: niTBV ? parseFloat(niTBV.toFixed(4)) : null,
    roe: roe ? parseFloat(roe.toFixed(4)) : null,
    rota: rota ? parseFloat(rota.toFixed(4)) : null,
    roaa: roaa ? parseFloat(roaa.toFixed(4)) : null,
    rotce: rotce ? parseFloat(rotce.toFixed(4)) : null,
    bvps: bookValuePerShare ? parseFloat(bookValuePerShare.toFixed(4)) : null,
    tbvps: tangibleBookValuePerShare ? parseFloat(tangibleBookValuePerShare.toFixed(4)) : null,
    grahamNum: grahamNumber ? parseFloat(grahamNumber.toFixed(4)) : null,
    grahamMoS: grahamMoS ? parseFloat(grahamMoS.toFixed(4)) : null,
    grahamMoSPct: grahamMoSPct ? parseFloat(grahamMoSPct.toFixed(4)) : null,
    // Dividend metrics
    ttmDividendPerShare: dividendMetrics.ttmDividendPerShare,
    dividendPayoutRatio: dividendMetrics.dividendPayoutRatio,
    dividendMethod: dividendMetrics.dividendMethod,
    // Bank-specific ratios
    efficiencyRatio: efficiencyRatio ? parseFloat(efficiencyRatio.toFixed(2)) : null,
    aclToLoans: aclToLoans ? parseFloat(aclToLoans.toFixed(2)) : null,
    provisionToAvgLoans: provisionToAvgLoans ? parseFloat(provisionToAvgLoans.toFixed(2)) : null,
    loansToAssets: loansToAssets ? parseFloat(loansToAssets.toFixed(2)) : null,
    depositsToAssets: depositsToAssets ? parseFloat(depositsToAssets.toFixed(2)) : null,
    loansToDeposits: loansToDeposits ? parseFloat(loansToDeposits.toFixed(2)) : null,
    cashSecuritiesToAssets: cashSecuritiesToAssets ? parseFloat(cashSecuritiesToAssets.toFixed(2)) : null,
    equityToAssets: equityToAssets ? parseFloat(equityToAssets.toFixed(2)) : null,
    tceToTa: tceToTa ? parseFloat(tceToTa.toFixed(2)) : null,
    dataDate: dataDate,
    isStale: isStale, // Flag if data is before 2024
    ttmMethod: netIncome?.method || 'unknown' // Track how TTM was calculated
  };
}

/**
 * Determine exchange from bank list data or SEC mapping
 * Exchange information now comes from the bank-list.json generated by discover-banks.cjs
 * which uses authoritative exchange directories (NASDAQ, NYSE, OTC)
 */
function determineExchange(ticker, companyName, bankListEntry) {
  // If we have bank list data with exchange info, use it
  if (bankListEntry && bankListEntry.exchange) {
    return bankListEntry.exchange;
  }

  // Fallback: Try to determine from SEC ticker map
  if (tickerToCikMap) {
    const upperTicker = ticker?.toUpperCase();
    const mapping = tickerToCikMap[upperTicker];
    // SEC's company_tickers.json doesn't include exchange, so we can't help here
  }

  // Last resort fallback for banks not in the list
  // This shouldn't happen in normal operation if bank-list.json is up to date
  return 'N/A';
}

/**
 * Process a single bank
 *
 * Features:
 * - Security type identification (common vs exchange-traded)
 * - Dividend metrics (TTM dividends, payout ratio)
 *
 * @param {string} ticker - Stock ticker symbol
 * @param {number} index - Index in the bank list
 * @param {Object} bankListEntry - Optional bank list entry with CIK, exchange, SIC info
 */
async function processBank(ticker, index, bankListEntry = null) {
  console.log(`\n[${index}] Processing ${ticker}...`);

  try {
    // Get company info and CIK
    // If we have bank list entry with CIK, use it directly
    let companyInfo;
    if (bankListEntry && bankListEntry.cik) {
      companyInfo = {
        cik: bankListEntry.cik,
        name: bankListEntry.companyName
      };
      console.log(`  ✓ Using bank list: ${companyInfo.name} (CIK: ${companyInfo.cik})`);
    } else {
      companyInfo = await getCompanyInfo(ticker);
      console.log(`  ✓ Found: ${companyInfo.name} (CIK: ${companyInfo.cik})`);
    }

    // Fetch company facts from SEC (XBRL financial data)
    const companyFacts = await getCompanyFacts(companyInfo.cik);
    console.log(`  ✓ Fetched SEC EDGAR company facts`);

    // Determine security type (common vs exchange-traded)
    // Exchange-traded securities include preferred stock, debt securities
    const securityTypeInfo = determineSecurityType(ticker, companyFacts);
    console.log(`  ✓ Security type: ${securityTypeInfo.securityType} (${securityTypeInfo.reason})`);

    // Get prior close price from Marketstack
    // Marketstack counts each symbol as 1 API request toward monthly quota
    // Skip price fetch for exchange-traded securities (they need different handling)
    let currentPrice = null;
    if (!securityTypeInfo.isExchangeTraded) {
      await delay(500); // Small delay between price requests
      currentPrice = await getCurrentPrice(ticker);
      if (currentPrice) {
        console.log(`  ✓ Current price: $${currentPrice.toFixed(2)}`);
      }
    } else {
      console.log(`  ⚠ Skipping price fetch for exchange-traded security`);
    }

    // Calculate metrics (pass isExchangeTraded to null out price metrics)
    const metrics = calculateMetrics(companyFacts, currentPrice, securityTypeInfo.isExchangeTraded);
    console.log(`  ✓ Calculated metrics (TTM: ${metrics.ttmMethod})`);

    // Add asterisk to ticker if data is stale (before 2024)
    const displayTicker = metrics.isStale ? `${ticker}*` : ticker;

    if (metrics.isStale) {
      console.log(`  ⚠ Warning: Data is stale (last report: ${metrics.dataDate})`);
    }

    // Get exchange from bank list entry (authoritative source)
    const exchange = determineExchange(ticker, companyInfo.name, bankListEntry);

    // Include SIC information if available
    const sicInfo = bankListEntry ? {
      sic: bankListEntry.sic,
      sicDescription: bankListEntry.sicDescription,
      otcTier: bankListEntry.otcTier
    } : {};

    return {
      id: `bank-${index}`,
      cik: companyInfo.cik,
      ticker: displayTicker,
      bankName: companyInfo.name,
      exchange: exchange,
      ...sicInfo,
      // Security type classification
      securityType: securityTypeInfo.securityType,
      isExchangeTraded: securityTypeInfo.isExchangeTraded,
      // Financial metrics (including dividend metrics)
      ...metrics,
      updatedAt: new Date().toISOString()
    };

  } catch (error) {
    console.error(`  ✗ Error processing ${ticker}: ${error.message}`);
    return null;
  }
}

/**
 * Main function
 */
async function main() {
  console.log('========================================');
  console.log('SEC EDGAR Bank Data Fetcher');
  console.log('========================================\n');
  console.log(`Node version: ${process.version}`);
  console.log(`Working directory: ${process.cwd()}`);
  console.log(`User-Agent: ${CONFIG.edgarUserAgent}`);
  console.log(`Started: ${new Date().toISOString()}\n`);

  // Verify axios is loaded
  try {
    console.log(`Axios loaded: ${typeof axios}`);
  } catch (err) {
    console.error('ERROR: axios not available:', err.message);
    process.exit(1);
  }

  // Load bank list from generated file (SEC EDGAR + SIC based)
  const bankList = loadBankList();

  // Determine which banks to process
  let banksToProcess;
  let useBankList = false;

  if (bankList && bankList.length > 0) {
    banksToProcess = bankList;
    useBankList = true;
    console.log(`\nProcessing ${banksToProcess.length} banks from SEC EDGAR SIC-based discovery`);

    // Build set of known base tickers for cross-reference in security type detection
    // This helps identify preferred shares (e.g., if BANF exists, BANFP is likely preferred)
    bankList.forEach(b => {
      if (b.ticker) {
        knownBaseTickers.add(b.ticker.toUpperCase());
      }
    });
    console.log(`Built cross-reference set with ${knownBaseTickers.size} known base tickers`);

    // Show breakdown by exchange
    const byExchange = {};
    bankList.forEach(b => {
      byExchange[b.exchange] = (byExchange[b.exchange] || 0) + 1;
    });
    console.log('By exchange:', Object.entries(byExchange).map(([e, c]) => `${e}: ${c}`).join(', '));
  } else {
    // Fallback to minimal ticker list
    banksToProcess = CONFIG.fallbackTickers.map(ticker => ({ ticker }));
    console.log(`\nUsing fallback ticker list: ${CONFIG.fallbackTickers.length} banks`);
    console.warn('Note: Run "node scripts/discover-banks.cjs" to generate complete bank list');
  }

  console.log(`\nBanks to process: ${banksToProcess.length}`);

  const results = [];
  const errors = [];

  // Process each bank sequentially
  for (let i = 0; i < banksToProcess.length; i++) {
    const bankEntry = banksToProcess[i];
    const ticker = bankEntry.ticker;

    // Pass the full bank entry if using bank list (includes CIK, exchange, SIC info)
    const bankData = await processBank(ticker, i, useBankList ? bankEntry : null);

    if (bankData) {
      results.push(bankData);
    } else {
      errors.push(ticker);
    }

    // Progress indicator every 10 banks
    if ((i + 1) % 10 === 0 || i === banksToProcess.length - 1) {
      console.log(`Progress: ${i + 1}/${banksToProcess.length}`);
    }
  }

  // Sort by market cap (descending)
  results.sort((a, b) => {
    if (!a.marketCap) return 1;
    if (!b.marketCap) return -1;
    return b.marketCap - a.marketCap;
  });

  // Save to JSON file (in public/ for Vite and GitHub Pages)
  const outputPath = path.join(__dirname, '..', 'public', 'data', 'banks.json');
  const outputDir = path.dirname(outputPath);

  console.log(`\nOutput path: ${outputPath}`);
  console.log(`Output directory: ${outputDir}`);

  // Create data directory if it doesn't exist
  try {
    if (!fs.existsSync(outputDir)) {
      console.log('Creating output directory...');
      fs.mkdirSync(outputDir, { recursive: true });
      console.log('✓ Directory created');
    } else {
      console.log('✓ Directory exists');
    }

    console.log('Writing JSON file...');
    fs.writeFileSync(outputPath, JSON.stringify(results, null, 2));
    console.log('✓ File written successfully');
  } catch (writeError) {
    console.error('ERROR writing output file:', writeError);
    throw writeError;
  }

  // Summary
  console.log('\n========================================');
  console.log('Summary');
  console.log('========================================');
  console.log(`Total banks in list: ${banksToProcess.length}`);
  console.log(`Successful: ${results.length}`);
  console.log(`Failed: ${errors.length}`);

  // Show exchange distribution in results
  const resultsByExchange = {};
  results.forEach(b => {
    resultsByExchange[b.exchange] = (resultsByExchange[b.exchange] || 0) + 1;
  });
  console.log(`\nResults by Exchange:`);
  for (const [exchange, count] of Object.entries(resultsByExchange).sort((a, b) => b[1] - a[1])) {
    console.log(`  ${exchange}: ${count}`);
  }

  if (errors.length > 0) {
    console.log(`\nFailed tickers: ${errors.join(', ')}`);
  }

  // Show stale data warnings
  const staleBanks = results.filter(b => b.isStale);
  if (staleBanks.length > 0) {
    console.log(`\n⚠ Stale Data Warning (${staleBanks.length} banks):`);
    console.log('The following banks have data from before 2024:');
    staleBanks.forEach(b => {
      console.log(`  - ${b.ticker} (${b.dataDate})`);
    });
    console.log('Note: Tickers marked with * indicate data not current');
  }

  // Show TTM calculation methods
  const ttmMethods = {};
  results.forEach(b => {
    const method = b.ttmMethod || 'unknown';
    ttmMethods[method] = (ttmMethods[method] || 0) + 1;
  });
  console.log(`\nTTM Calculation Methods:`);
  Object.entries(ttmMethods).forEach(([method, count]) => {
    console.log(`  - ${method}: ${count} banks`);
  });

  console.log(`\nOutput saved to: ${outputPath}`);
  console.log(`File size: ${fs.statSync(outputPath).size} bytes`);
  console.log(`Completed: ${new Date().toISOString()}`);
  console.log('========================================\n');

  // Exit successfully if we got at least some data
  // Only fail if ALL banks failed
  if (results.length === 0) {
    console.error('FATAL: No banks were processed successfully!');
    process.exit(1);
  } else {
    console.log(`✓ Success! Processed ${results.length}/${banksToProcess.length} banks`);
    process.exit(0);
  }
}

// Run main function
main().catch(error => {
  console.error('\n========================================');
  console.error('FATAL ERROR');
  console.error('========================================');
  console.error('Error message:', error.message);
  console.error('Error stack:', error.stack);
  console.error('========================================\n');
  process.exit(1);
});
