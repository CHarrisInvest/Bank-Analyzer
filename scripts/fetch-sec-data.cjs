#!/usr/bin/env node
/**
 * Standalone SEC EDGAR Data Fetcher for GitHub Actions
 * Fetches bank financial data from SEC EDGAR API and saves to JSON file
 *
 * Features:
 * - Security type identification (common shares vs exchange-traded securities)
 * - Dividend metrics (TTM dividends, dividend payout ratio)
 * - US vs Non-US bank holding company classification
 */

const axios = require('axios');
const fs = require('fs');
const path = require('path');

// Configuration
const CONFIG = {
  edgarUserAgent: process.env.EDGAR_USER_AGENT || 'Bank-Analyzer github-actions@example.com',
  requestDelay: 150, // 150ms = ~6 req/sec (under SEC's 10 req/sec limit)
  // Bank list is now loaded dynamically from bank-list.json (generated by discover-banks.cjs)
  // Falls back to a minimal set if the file doesn't exist yet
  fallbackTickers: ['JPM', 'BAC', 'WFC', 'C', 'USB', 'PNC'],

  /**
   * Patterns to identify exchange-traded securities (preferred stock, debt securities)
   * These are securities that trade on exchanges but are NOT common shares
   * Examples: PRA, PRB (preferred), bonds, notes
   */
  exchangeTradedPatterns: [
    /PR[A-Z]$/i,        // Preferred stock (e.g., BAC-PRA, WFC-PRB)
    /-P[A-Z]$/i,        // Alternative preferred notation
    /\.P[A-Z]$/i,       // Dot notation preferred
    /P$/i,              // Single P suffix for some preferreds (rare)
  ],

  /**
   * US state codes recognized by SEC (2-letter codes)
   * Non-US jurisdictions use different codes
   */
  usStateCodes: [
    'AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA',
    'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD',
    'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ',
    'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC',
    'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY',
    'DC', 'PR', 'VI', 'GU', 'AS', 'MP' // Plus territories
  ]
};

/**
 * Load bank list from generated bank-list.json file
 * This file is produced by discover-banks.cjs which queries SEC EDGAR by SIC code
 */
function loadBankList() {
  const bankListPath = path.join(__dirname, '..', 'public', 'data', 'bank-list.json');

  try {
    if (fs.existsSync(bankListPath)) {
      const data = JSON.parse(fs.readFileSync(bankListPath, 'utf8'));
      const banks = data.banks || [];

      // Filter to only banks with tickers and valid exchanges (NYSE, NASDAQ, OTC)
      const validBanks = banks.filter(b =>
        b.ticker &&
        ['NYSE', 'NASDAQ', 'OTC'].includes(b.exchange)
      );

      console.log(`✓ Loaded ${validBanks.length} banks from bank-list.json`);
      console.log(`  Source: SEC EDGAR + SIC Classification`);
      console.log(`  Generated: ${data.metadata?.generatedAt || 'unknown'}`);

      return validBanks;
    } else {
      console.warn('Warning: bank-list.json not found, using fallback tickers');
      console.warn('Run "node scripts/discover-banks.cjs" to generate the bank list');
      return null;
    }
  } catch (error) {
    console.warn(`Warning: Could not load bank-list.json: ${error.message}`);
    return null;
  }
}

// Global cache for SEC ticker-to-CIK mapping
let tickerToCikMap = null;

// Delay helper
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

/**
 * Get prior close stock price from Marketstack API
 * Requires MARKETSTACK_API_KEY environment variable
 * Uses EOD (end-of-day) endpoint for prior close prices
 * Commercial use allowed on Professional plan ($49.99/mo) and above
 * @see https://marketstack.com/documentation
 */
async function getCurrentPrice(ticker) {
  const apiKey = process.env.MARKETSTACK_API_KEY;

  if (!apiKey) {
    console.warn(`  Warning: MARKETSTACK_API_KEY not set, skipping price fetch for ${ticker}`);
    return null;
  }

  try {
    // Using Marketstack EOD endpoint for prior close price
    const url = `http://api.marketstack.com/v1/eod/latest?access_key=${apiKey}&symbols=${ticker}`;
    const response = await axios.get(url, {
      timeout: 15000,
      headers: { 'User-Agent': 'Bank-Analyzer/1.0' }
    });

    // Check for API error
    if (response.data?.error) {
      console.warn(`  Warning: Marketstack API error for ${ticker}: ${response.data.error.message}`);
      return null;
    }

    // Extract close price from the first data entry
    const data = response.data?.data?.[0];
    const price = data?.close;
    return price ? parseFloat(price) : null;
  } catch (error) {
    console.warn(`  Warning: Could not fetch price for ${ticker}: ${error.message}`);
    return null;
  }
}

/**
 * Load SEC's ticker-to-CIK mapping (cached globally)
 */
async function loadTickerToCikMap() {
  if (tickerToCikMap) {
    return tickerToCikMap; // Return cached version
  }

  try {
    console.log('Loading SEC ticker-to-CIK mapping...');
    await delay(CONFIG.requestDelay);

    const response = await axios.get(
      'https://www.sec.gov/files/company_tickers.json',
      {
        headers: { 'User-Agent': CONFIG.edgarUserAgent },
        timeout: 30000
      }
    );

    // Convert array format to ticker-keyed map
    // SEC returns: { "0": { "cik_str": 320193, "ticker": "AAPL", "title": "Apple Inc." }, ... }
    tickerToCikMap = {};

    for (const key in response.data) {
      const company = response.data[key];
      if (company.ticker && company.cik_str) {
        // Store with uppercase ticker as key
        tickerToCikMap[company.ticker.toUpperCase()] = {
          cik: String(company.cik_str).padStart(10, '0'),
          name: company.title
        };
      }
    }

    console.log(`✓ Loaded ${Object.keys(tickerToCikMap).length} company mappings`);
    return tickerToCikMap;
  } catch (error) {
    throw new Error(`Failed to load ticker-to-CIK map: ${error.message}`);
  }
}

/**
 * Get company CIK and info from ticker
 */
async function getCompanyInfo(ticker) {
  try {
    // Load mapping if not already loaded
    const map = await loadTickerToCikMap();

    const upperTicker = ticker.toUpperCase();
    const company = map[upperTicker];

    if (!company) {
      throw new Error(`Ticker ${ticker} not found in SEC database`);
    }

    return {
      cik: company.cik,
      name: company.name
    };
  } catch (error) {
    throw new Error(`Failed to get company info: ${error.message}`);
  }
}

/**
 * Fetch company facts from SEC EDGAR
 */
async function getCompanyFacts(cik) {
  try {
    await delay(CONFIG.requestDelay);

    const paddedCik = cik.padStart(10, '0');
    const url = `https://data.sec.gov/api/xbrl/companyfacts/CIK${paddedCik}.json`;

    const response = await axios.get(url, {
      headers: { 'User-Agent': CONFIG.edgarUserAgent },
      timeout: 30000
    });

    return response.data;
  } catch (error) {
    throw new Error(`Failed to fetch company facts: ${error.message}`);
  }
}

/**
 * Fetch company submissions from SEC EDGAR
 * Returns company metadata including state of incorporation and business address
 * This is used for US vs Non-US classification
 *
 * @param {string} cik - Company CIK number
 * @returns {Promise<Object>} Company submission data with incorporation and address info
 */
async function getCompanySubmissions(cik) {
  try {
    await delay(CONFIG.requestDelay);

    const paddedCik = cik.padStart(10, '0');
    const url = `https://data.sec.gov/submissions/CIK${paddedCik}.json`;

    const response = await axios.get(url, {
      headers: { 'User-Agent': CONFIG.edgarUserAgent },
      timeout: 30000
    });

    return response.data;
  } catch (error) {
    // Don't fail the whole process if we can't get submissions
    console.warn(`  Warning: Could not fetch company submissions: ${error.message}`);
    return null;
  }
}

/**
 * Determine security type based on ticker symbol and SEC EDGAR data
 *
 * Security Types:
 * - "common": Common shares (standard equity)
 * - "exchange-traded": Preferred stock, debt securities, or other exchange-traded instruments
 * - "both": Company issues both (rare for individual tickers, more for company-level)
 *
 * Classification Logic:
 * 1. Check ticker symbol patterns for preferred/debt indicators (PR, .P, -P suffixes)
 * 2. Check SEC EDGAR data for preferred stock outstanding
 * 3. Default to "common" if no indicators found
 *
 * @param {string} ticker - Stock ticker symbol
 * @param {Object} companyFacts - SEC EDGAR company facts data
 * @returns {Object} Security type classification with reasoning
 */
function determineSecurityType(ticker, companyFacts) {
  const upperTicker = ticker?.toUpperCase() || '';
  let securityType = 'common';
  let isExchangeTraded = false;
  let reason = 'default';

  // Check 1: Ticker symbol patterns indicating preferred/debt securities
  for (const pattern of CONFIG.exchangeTradedPatterns) {
    if (pattern.test(upperTicker)) {
      securityType = 'exchange-traded';
      isExchangeTraded = true;
      reason = `ticker pattern match: ${pattern}`;
      break;
    }
  }

  // Check 2: If not already identified, check SEC EDGAR data for preferred stock
  // Note: This checks if the COMPANY has preferred stock, not if this ticker IS preferred
  // For most common stock tickers, this will show "both" if the company has preferred outstanding
  if (!isExchangeTraded && companyFacts) {
    // Check for preferred stock value outstanding
    const preferredStock = companyFacts.facts?.['us-gaap']?.['PreferredStockValue']?.units?.USD ||
                          companyFacts.facts?.['us-gaap']?.['PreferredStockValueOutstanding']?.units?.USD;

    if (preferredStock && preferredStock.length > 0) {
      // Get most recent value
      const sorted = preferredStock
        .filter(item => item.val && item.end)
        .sort((a, b) => new Date(b.end) - new Date(a.end));

      if (sorted.length > 0 && sorted[0].val > 0) {
        // Company has preferred stock outstanding, but this ticker is still common
        // The "both" classification is at company level, not ticker level
        reason = 'common stock with company preferred stock outstanding';
      }
    }
  }

  return {
    securityType,
    isExchangeTraded,
    reason
  };
}

/**
 * Determine if bank is US-based or Non-US-based
 *
 * Classification Logic (using SEC EDGAR data):
 * 1. Check state of incorporation - Non-US states/countries indicate foreign bank
 * 2. Check business address country
 * 3. Check mailing address country
 *
 * Assumptions & Limitations:
 * - SEC filings are required for US-listed companies, so all banks in our dataset file with SEC
 * - State of incorporation is the most reliable indicator
 * - Some US-incorporated subsidiaries of foreign parents may be classified as US
 * - Address data may not always indicate ultimate parent jurisdiction
 *
 * @param {Object} companySubmissions - SEC company submissions data
 * @returns {Object} Country classification with confidence and reasoning
 */
function determineCountryClassification(companySubmissions) {
  if (!companySubmissions) {
    return {
      isUS: true, // Default to US if we can't determine
      country: 'US',
      confidence: 'low',
      reason: 'no submission data available, defaulting to US'
    };
  }

  const stateOfIncorp = companySubmissions.stateOfIncorporation?.toUpperCase();
  const addresses = companySubmissions.addresses || {};

  // Check 1: State of incorporation
  if (stateOfIncorp) {
    const isUSState = CONFIG.usStateCodes.includes(stateOfIncorp);
    if (isUSState) {
      return {
        isUS: true,
        country: 'US',
        stateOfIncorporation: stateOfIncorp,
        confidence: 'high',
        reason: `incorporated in US state: ${stateOfIncorp}`
      };
    } else {
      // Non-US incorporation code
      return {
        isUS: false,
        country: stateOfIncorp, // Foreign jurisdiction code
        stateOfIncorporation: stateOfIncorp,
        confidence: 'high',
        reason: `incorporated in non-US jurisdiction: ${stateOfIncorp}`
      };
    }
  }

  // Check 2: Business address
  const businessAddr = addresses.business || {};
  const businessCountry = businessAddr.stateOrCountry?.toUpperCase() ||
                         businessAddr.country?.toUpperCase();

  if (businessCountry) {
    // Check if it's a US state code or "US"/"USA"
    const isUSAddress = CONFIG.usStateCodes.includes(businessCountry) ||
                       ['US', 'USA', 'UNITED STATES'].includes(businessCountry);

    if (!isUSAddress) {
      return {
        isUS: false,
        country: businessCountry,
        confidence: 'medium',
        reason: `business address in: ${businessCountry}`
      };
    }
  }

  // Check 3: Mailing address
  const mailingAddr = addresses.mailing || {};
  const mailingCountry = mailingAddr.stateOrCountry?.toUpperCase() ||
                        mailingAddr.country?.toUpperCase();

  if (mailingCountry) {
    const isUSAddress = CONFIG.usStateCodes.includes(mailingCountry) ||
                       ['US', 'USA', 'UNITED STATES'].includes(mailingCountry);

    if (!isUSAddress) {
      return {
        isUS: false,
        country: mailingCountry,
        confidence: 'medium',
        reason: `mailing address in: ${mailingCountry}`
      };
    }
  }

  // Default: Assume US-based
  return {
    isUS: true,
    country: 'US',
    confidence: 'medium',
    reason: 'no non-US indicators found'
  };
}

/**
 * Extract dividend data from SEC EDGAR company facts
 *
 * Dividend XBRL Concepts (in order of preference):
 * 1. CommonStockDividendsPerShareDeclared - Dividends declared per share
 * 2. CommonStockDividendsPerShareCashPaid - Dividends actually paid per share
 * 3. DividendsCommonStockCash - Total cash dividends on common stock
 * 4. PaymentsOfDividendsCommonStock - Cash outflow for common dividends
 *
 * TTM Calculation:
 * - Sum the last 4 quarters of dividend payments/declarations
 * - For per-share values, use directly; for totals, divide by shares outstanding
 *
 * @param {Object} companyFacts - SEC EDGAR company facts
 * @param {number} sharesOutstanding - Number of shares outstanding (for ratio calculations)
 * @param {number} netIncome - TTM net income (for payout ratio)
 * @param {number} eps - TTM EPS (for payout ratio)
 * @returns {Object} Dividend metrics
 */
function extractDividendMetrics(companyFacts, sharesOutstanding, netIncome, eps) {
  if (!companyFacts) {
    return {
      ttmDividendPerShare: null,
      dividendPayoutRatio: null,
      dividendMethod: null
    };
  }

  // Try to get TTM dividends per share using various XBRL concepts
  // Priority order based on data quality and availability

  // Method 1: CommonStockDividendsPerShareDeclared (most accurate for per-share)
  let dps = getTTMValueForDividends(companyFacts, 'CommonStockDividendsPerShareDeclared');

  // Method 2: CommonStockDividendsPerShareCashPaid
  if (!dps) {
    dps = getTTMValueForDividends(companyFacts, 'CommonStockDividendsPerShareCashPaid');
  }

  // Method 3: Try Dividends (generic concept)
  if (!dps) {
    dps = getTTMValueForDividends(companyFacts, 'Dividends');
  }

  // If we have per-share dividend data
  let ttmDividendPerShare = null;
  let dividendPayoutRatio = null;
  let dividendMethod = null;

  if (dps && dps.value !== null && dps.value !== undefined) {
    ttmDividendPerShare = dps.value;
    dividendMethod = dps.method || 'per-share';

    // Calculate dividend payout ratio
    // Payout Ratio = DPS / EPS (or Total Dividends / Net Income)
    if (eps && eps > 0) {
      dividendPayoutRatio = (ttmDividendPerShare / eps) * 100;
    }
  } else {
    // Method 4: Try total dividend payments and divide by shares
    const totalDividends = getTTMValueForDividends(companyFacts, 'PaymentsOfDividendsCommonStock') ||
                          getTTMValueForDividends(companyFacts, 'DividendsCash') ||
                          getTTMValueForDividends(companyFacts, 'PaymentsOfDividends');

    if (totalDividends && totalDividends.value && sharesOutstanding) {
      ttmDividendPerShare = totalDividends.value / sharesOutstanding;
      dividendMethod = 'total-divided-by-shares';

      // Calculate payout ratio using total dividends / net income
      if (netIncome && netIncome > 0) {
        dividendPayoutRatio = (totalDividends.value / netIncome) * 100;
      }
    }
  }

  return {
    ttmDividendPerShare: ttmDividendPerShare ? parseFloat(ttmDividendPerShare.toFixed(4)) : null,
    dividendPayoutRatio: dividendPayoutRatio ? parseFloat(dividendPayoutRatio.toFixed(2)) : null,
    dividendMethod
  };
}

/**
 * Get TTM value specifically for dividend-related concepts
 * Similar to getTTMValue but handles per-share values differently (no division needed)
 *
 * @param {Object} companyFacts - Company facts data
 * @param {string} concept - XBRL concept name
 * @returns {Object|null} TTM value with method
 */
function getTTMValueForDividends(companyFacts, concept) {
  try {
    const conceptData = companyFacts.facts?.['us-gaap']?.[concept];
    if (!conceptData) return null;

    // Check for USD values first (for total amounts)
    let units = conceptData.units?.USD;

    // If no USD, check for USD/shares (for per-share values)
    if (!units || units.length === 0) {
      units = conceptData.units?.['USD/shares'];
    }

    if (!units || units.length === 0) return null;

    // Filter for annual and quarterly data
    const annualData = units
      .filter(item => item.form === '10-K' && item.val !== undefined && item.end)
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    const quarterlyData = units
      .filter(item => item.form === '10-Q' && item.val !== undefined && item.end && item.fp)
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    // If annual is most recent, use it
    const mostRecentAnnualDate = annualData.length > 0 ? new Date(annualData[0].end) : null;
    const mostRecentQuarterlyDate = quarterlyData.length > 0 ? new Date(quarterlyData[0].end) : null;

    if (mostRecentAnnualDate && (!mostRecentQuarterlyDate || mostRecentAnnualDate >= mostRecentQuarterlyDate)) {
      return {
        value: annualData[0].val,
        date: annualData[0].end,
        method: 'annual'
      };
    }

    // Try to sum quarters
    if (quarterlyData.length >= 4) {
      const last4Q = quarterlyData.slice(0, 4);
      const ttmValue = last4Q.reduce((sum, q) => sum + (q.val || 0), 0);
      return {
        value: ttmValue,
        date: last4Q[0].end,
        method: 'sum-4Q'
      };
    }

    // Fallback to annual if available
    if (annualData.length > 0) {
      return {
        value: annualData[0].val,
        date: annualData[0].end,
        method: 'annual-fallback'
      };
    }

    return null;
  } catch (error) {
    return null;
  }
}

/**
 * Get latest point-in-time value (for balance sheet items like Assets, Equity)
 */
function getLatestPointInTimeValue(companyFacts, concept, taxonomy = 'us-gaap') {
  try {
    const conceptData = companyFacts.facts?.[taxonomy]?.[concept];
    if (!conceptData) return null;

    const usdUnits = conceptData.units?.USD;
    if (!usdUnits || usdUnits.length === 0) return null;

    // Get most recent value (from either 10-K or 10-Q)
    const allData = usdUnits
      .filter(item => (item.form === '10-K' || item.form === '10-Q') && item.val && item.end)
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    if (allData.length > 0) {
      return {
        value: allData[0].val,
        date: allData[0].end,
        form: allData[0].form
      };
    }

    return null;
  } catch (error) {
    return null;
  }
}

/**
 * Get latest two point-in-time values for calculating averages (e.g., average assets)
 * Returns current and prior period values
 */
function getLatestTwoPointInTimeValues(companyFacts, concept, taxonomy = 'us-gaap') {
  try {
    const conceptData = companyFacts.facts?.[taxonomy]?.[concept];
    if (!conceptData) return null;

    const usdUnits = conceptData.units?.USD;
    if (!usdUnits || usdUnits.length === 0) return null;

    // Get all values sorted by date (most recent first)
    const allData = usdUnits
      .filter(item => (item.form === '10-K' || item.form === '10-Q') && item.val && item.end)
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    if (allData.length >= 2) {
      return {
        current: {
          value: allData[0].val,
          date: allData[0].end,
          form: allData[0].form
        },
        prior: {
          value: allData[1].val,
          date: allData[1].end,
          form: allData[1].form
        }
      };
    } else if (allData.length === 1) {
      // Only one value available, use it for both (average = current)
      return {
        current: {
          value: allData[0].val,
          date: allData[0].end,
          form: allData[0].form
        },
        prior: null
      };
    }

    return null;
  } catch (error) {
    return null;
  }
}

/**
 * Get TTM (Trailing Twelve Months) value for period-based items like Net Income, EPS
 * Always starts from the most recent filing period (10-K or 10-Q) to show the most current data.
 *
 * Logic:
 * - If most recent filing is a 10-K: Use it directly (it's already a full year / TTM)
 * - If most recent filing is a 10-Q: Calculate TTM by summing the last 4 quarters
 *   - Q1, Q2, Q3 come from 10-Q filings
 *   - Q4 is derived from: Annual (10-K) value - Q1 - Q2 - Q3 of that fiscal year
 */
function getTTMValue(companyFacts, concept, taxonomy = 'us-gaap') {
  try {
    const conceptData = companyFacts.facts?.[taxonomy]?.[concept];
    if (!conceptData) return null;

    const usdUnits = conceptData.units?.USD;
    if (!usdUnits || usdUnits.length === 0) return null;

    // Get all annual data (10-K filings)
    const annualData = usdUnits
      .filter(item => item.form === '10-K' && item.val !== undefined && item.val !== null && item.end && item.fy)
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    // Get all quarterly data (10-Q filings with Q1, Q2, Q3 periods)
    const quarterlyData = usdUnits
      .filter(item =>
        item.form === '10-Q' &&
        item.val !== undefined && item.val !== null &&
        item.end &&
        item.fy &&
        item.fp &&
        ['Q1', 'Q2', 'Q3'].includes(item.fp) // Only Q1-Q3 from 10-Q filings
      )
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    // Determine the most recent filing date
    const mostRecentAnnualDate = annualData.length > 0 ? new Date(annualData[0].end) : null;
    const mostRecentQuarterlyDate = quarterlyData.length > 0 ? new Date(quarterlyData[0].end) : null;

    // Case 1: No data at all
    if (!mostRecentAnnualDate && !mostRecentQuarterlyDate) {
      return null;
    }

    // Case 2: Only annual data available, or 10-K is more recent than any 10-Q
    if (mostRecentAnnualDate && (!mostRecentQuarterlyDate || mostRecentAnnualDate >= mostRecentQuarterlyDate)) {
      return {
        value: annualData[0].val,
        date: annualData[0].end,
        form: '10-K',
        method: 'annual'
      };
    }

    // Case 3: 10-Q is more recent - calculate TTM from quarters
    // We need to build a list of all quarters including derived Q4 values

    // Build a map of quarterly values by fiscal year and period
    const quarterMap = new Map(); // Key: "YYYY-Q#", Value: { value, end, fy, fp, source }

    // Add Q1, Q2, Q3 from 10-Q filings
    for (const q of quarterlyData) {
      const key = `${q.fy}-${q.fp}`;
      if (!quarterMap.has(key)) {
        quarterMap.set(key, {
          value: q.val,
          end: q.end,
          fy: q.fy,
          fp: q.fp,
          source: '10-Q'
        });
      }
    }

    // Derive Q4 values from annual data
    // Q4 = Annual - Q1 - Q2 - Q3 for the same fiscal year
    for (const annual of annualData) {
      const fy = annual.fy;
      const q1Key = `${fy}-Q1`;
      const q2Key = `${fy}-Q2`;
      const q3Key = `${fy}-Q3`;
      const q4Key = `${fy}-Q4`;

      // Only derive Q4 if we don't already have it and have the annual value
      if (!quarterMap.has(q4Key)) {
        const q1 = quarterMap.get(q1Key);
        const q2 = quarterMap.get(q2Key);
        const q3 = quarterMap.get(q3Key);

        if (q1 && q2 && q3) {
          // Derive Q4 from annual minus Q1-Q3
          const q4Value = annual.val - q1.value - q2.value - q3.value;
          quarterMap.set(q4Key, {
            value: q4Value,
            end: annual.end, // Use annual end date for Q4
            fy: fy,
            fp: 'Q4',
            source: 'derived'
          });
        } else {
          // If we don't have all quarters, use the annual value as Q4 approximation
          // This handles cases where we might be missing some Q data
          quarterMap.set(q4Key, {
            value: annual.val, // Use full annual as placeholder (not ideal but better than nothing)
            end: annual.end,
            fy: fy,
            fp: 'Q4',
            source: '10-K-fallback'
          });
        }
      }
    }

    // Convert map to sorted array (most recent first)
    const allQuarters = Array.from(quarterMap.values())
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    if (allQuarters.length >= 4) {
      // Sum the last 4 quarters to get TTM
      const last4Quarters = allQuarters.slice(0, 4);
      const ttmValue = last4Quarters.reduce((sum, q) => sum + q.value, 0);

      return {
        value: ttmValue,
        date: last4Quarters[0].end, // Most recent quarter end date
        form: '10-Q',
        method: 'sum-4Q',
        quarters: last4Quarters.map(q => ({
          end: q.end,
          period: q.fp,
          value: q.value,
          source: q.source
        }))
      };
    }

    // Fallback: If we have the most recent annual data, use it
    if (annualData.length > 0) {
      console.warn(`  Warning: Using annual data as fallback for ${concept} (insufficient quarterly data)`);
      return {
        value: annualData[0].val,
        date: annualData[0].end,
        form: '10-K',
        method: 'annual-fallback'
      };
    }

    // Last resort: Use whatever quarterly data we have
    if (allQuarters.length > 0) {
      console.warn(`  Warning: Using partial quarterly data for ${concept} (only ${allQuarters.length} quarters available)`);
      const partialTTM = allQuarters.reduce((sum, q) => sum + q.value, 0);
      return {
        value: partialTTM,
        date: allQuarters[0].end,
        form: '10-Q',
        method: `partial-${allQuarters.length}Q`,
        quarters: allQuarters.map(q => ({
          end: q.end,
          period: q.fp,
          value: q.value,
          source: q.source
        }))
      };
    }

    return null;
  } catch (error) {
    return null;
  }
}

/**
 * Calculate all banking metrics using TTM for period-based items
 *
 * @param {Object} companyFacts - SEC EDGAR company facts data
 * @param {number} currentPrice - Current stock price
 * @param {boolean} isExchangeTraded - If true, null out price-related metrics
 * @returns {Object} Calculated financial metrics
 */
function calculateMetrics(companyFacts, currentPrice, isExchangeTraded = false) {
  // Balance sheet items (point-in-time) - use latest value
  const totalAssets = getLatestPointInTimeValue(companyFacts, 'Assets');
  const totalEquity = getLatestPointInTimeValue(companyFacts, 'StockholdersEquity') ||
                      getLatestPointInTimeValue(companyFacts, 'StockholdersEquityIncludingPortionAttributableToNoncontrollingInterest');
  const sharesOutstanding = getLatestPointInTimeValue(companyFacts, 'CommonStockSharesOutstanding') ||
                            getLatestPointInTimeValue(companyFacts, 'WeightedAverageNumberOfSharesOutstandingBasic');
  const goodwill = getLatestPointInTimeValue(companyFacts, 'Goodwill');
  const intangibleAssets = getLatestPointInTimeValue(companyFacts, 'IntangibleAssetsNetExcludingGoodwill');

  // Preferred stock for tangible common equity calculation
  const preferredStock = getLatestPointInTimeValue(companyFacts, 'PreferredStockValue') ||
                         getLatestPointInTimeValue(companyFacts, 'PreferredStockValueOutstanding');

  // Get two periods of assets for average assets calculation (ROAA)
  const assetsForAverage = getLatestTwoPointInTimeValues(companyFacts, 'Assets');

  // Income statement items (period-based) - use TTM
  const netIncome = getTTMValue(companyFacts, 'NetIncomeLoss') ||
                    getTTMValue(companyFacts, 'ProfitLoss') ||
                    getTTMValue(companyFacts, 'NetIncomeLossAvailableToCommonStockholdersBasic');
  const eps = getTTMValue(companyFacts, 'EarningsPerShareBasic') ||
              getTTMValue(companyFacts, 'EarningsPerShareDiluted');

  // Determine most recent data date
  const dataDate = netIncome?.date || totalEquity?.date || totalAssets?.date;

  // Check if data is stale (before 2024)
  const isStale = dataDate ? new Date(dataDate) < new Date('2024-01-01') : false;

  // Log TTM calculation method for debugging
  if (netIncome?.method) {
    console.log(`  Net Income TTM: ${netIncome.method} (${netIncome.form}) as of ${netIncome.date}`);
    if (netIncome.quarters && netIncome.quarters.length > 0) {
      console.log(`    Quarters used: ${netIncome.quarters.map(q => `${q.period}(${q.source})`).join(', ')}`);
    }
  }
  if (eps?.method) {
    console.log(`  EPS TTM: ${eps.method} (${eps.form}) as of ${eps.date}`);
  }

  // Extract dividend metrics
  // Note: Dividends are null for exchange-traded securities (non-common shares)
  const dividendMetrics = isExchangeTraded ? {
    ttmDividendPerShare: null,
    dividendPayoutRatio: null,
    dividendMethod: null
  } : extractDividendMetrics(
    companyFacts,
    sharesOutstanding?.value,
    netIncome?.value,
    eps?.value
  );

  if (dividendMetrics.ttmDividendPerShare !== null) {
    console.log(`  TTM Dividend: $${dividendMetrics.ttmDividendPerShare.toFixed(4)} (${dividendMetrics.dividendMethod})`);
    if (dividendMetrics.dividendPayoutRatio !== null) {
      console.log(`  Dividend Payout Ratio: ${dividendMetrics.dividendPayoutRatio.toFixed(1)}%`);
    }
  }

  // Calculate derived values
  const tangibleBookValue = totalEquity?.value ?
    totalEquity.value - (goodwill?.value || 0) - (intangibleAssets?.value || 0) : null;

  // Tangible Common Equity = Total Equity - Preferred Stock - Goodwill - Intangible Assets
  const tangibleCommonEquity = totalEquity?.value ?
    totalEquity.value - (preferredStock?.value || 0) - (goodwill?.value || 0) - (intangibleAssets?.value || 0) : null;

  // Tangible Assets = Total Assets - Goodwill - Intangible Assets
  const tangibleAssets = totalAssets?.value ?
    totalAssets.value - (goodwill?.value || 0) - (intangibleAssets?.value || 0) : null;

  // Average Assets for ROAA calculation
  const averageAssets = assetsForAverage?.current?.value && assetsForAverage?.prior?.value ?
    (assetsForAverage.current.value + assetsForAverage.prior.value) / 2 :
    (assetsForAverage?.current?.value || null);

  const marketCap = currentPrice && sharesOutstanding?.value ?
    currentPrice * sharesOutstanding.value : null;

  const bookValuePerShare = totalEquity?.value && sharesOutstanding?.value ?
    totalEquity.value / sharesOutstanding.value : null;

  const tangibleBookValuePerShare = tangibleBookValue && sharesOutstanding?.value ?
    tangibleBookValue / sharesOutstanding.value : null;

  // Calculate ratios
  const pni = marketCap && netIncome?.value && netIncome.value > 0 ?
    marketCap / netIncome.value : null;

  const ptbvps = currentPrice && tangibleBookValuePerShare && tangibleBookValuePerShare > 0 ?
    currentPrice / tangibleBookValuePerShare : null;

  const mktCapSE = marketCap && totalEquity?.value && totalEquity.value > 0 ?
    marketCap / totalEquity.value : null;

  const niTBV = netIncome?.value && tangibleBookValue && tangibleBookValue > 0 ?
    netIncome.value / tangibleBookValue : null;

  // ROE = Net Income / Total Equity
  const roe = netIncome?.value && totalEquity?.value && totalEquity.value > 0 ?
    (netIncome.value / totalEquity.value) * 100 : null;

  // Return on Tangible Assets = Net Income / Tangible Assets
  // (Tangible Assets = Total Assets - Goodwill - Intangible Assets)
  const rota = netIncome?.value && tangibleAssets && tangibleAssets > 0 ?
    (netIncome.value / tangibleAssets) * 100 : null;

  // Return on Average Assets (ROAA) = Net Income / Average Total Assets
  const roaa = netIncome?.value && averageAssets && averageAssets > 0 ?
    (netIncome.value / averageAssets) * 100 : null;

  // Return on Tangible Common Equity (ROTCE) = Net Income / Tangible Common Equity
  const rotce = netIncome?.value && tangibleCommonEquity && tangibleCommonEquity > 0 ?
    (netIncome.value / tangibleCommonEquity) * 100 : null;

  // Graham metrics
  const grahamNumber = eps?.value && bookValuePerShare && eps.value > 0 && bookValuePerShare > 0 ?
    Math.sqrt(22.5 * eps.value * bookValuePerShare) : null;

  const grahamMoS = grahamNumber && currentPrice ?
    grahamNumber - currentPrice : null;

  const grahamMoSPct = grahamNumber && currentPrice && currentPrice > 0 ?
    ((grahamNumber - currentPrice) / currentPrice) * 100 : null;

  // For exchange-traded securities (preferred, debt), null out price-related metrics
  // These metrics don't apply to non-common shares
  if (isExchangeTraded) {
    return {
      price: null,
      marketCap: null,
      pni: null,
      ptbvps: null,
      mktCapSE: null,
      niTBV: niTBV ? parseFloat(niTBV.toFixed(4)) : null, // Keep non-price metrics
      roe: roe ? parseFloat(roe.toFixed(4)) : null,
      rota: rota ? parseFloat(rota.toFixed(4)) : null,
      roaa: roaa ? parseFloat(roaa.toFixed(4)) : null,
      rotce: rotce ? parseFloat(rotce.toFixed(4)) : null,
      bvps: null,
      tbvps: null,
      grahamNum: null,
      grahamMoS: null,
      grahamMoSPct: null,
      // Dividend metrics null for exchange-traded securities
      ttmDividendPerShare: null,
      dividendPayoutRatio: null,
      dividendMethod: null,
      dataDate: dataDate,
      isStale: isStale,
      ttmMethod: netIncome?.method || 'unknown'
    };
  }

  return {
    price: currentPrice,
    marketCap: marketCap ? marketCap / 1000000 : null, // Convert to millions
    pni: pni ? parseFloat(pni.toFixed(4)) : null,
    ptbvps: ptbvps ? parseFloat(ptbvps.toFixed(4)) : null,
    mktCapSE: mktCapSE ? parseFloat(mktCapSE.toFixed(4)) : null,
    niTBV: niTBV ? parseFloat(niTBV.toFixed(4)) : null,
    roe: roe ? parseFloat(roe.toFixed(4)) : null,
    rota: rota ? parseFloat(rota.toFixed(4)) : null,
    roaa: roaa ? parseFloat(roaa.toFixed(4)) : null,
    rotce: rotce ? parseFloat(rotce.toFixed(4)) : null,
    bvps: bookValuePerShare ? parseFloat(bookValuePerShare.toFixed(4)) : null,
    tbvps: tangibleBookValuePerShare ? parseFloat(tangibleBookValuePerShare.toFixed(4)) : null,
    grahamNum: grahamNumber ? parseFloat(grahamNumber.toFixed(4)) : null,
    grahamMoS: grahamMoS ? parseFloat(grahamMoS.toFixed(4)) : null,
    grahamMoSPct: grahamMoSPct ? parseFloat(grahamMoSPct.toFixed(4)) : null,
    // Dividend metrics
    ttmDividendPerShare: dividendMetrics.ttmDividendPerShare,
    dividendPayoutRatio: dividendMetrics.dividendPayoutRatio,
    dividendMethod: dividendMetrics.dividendMethod,
    dataDate: dataDate,
    isStale: isStale, // Flag if data is before 2024
    ttmMethod: netIncome?.method || 'unknown' // Track how TTM was calculated
  };
}

/**
 * Determine exchange from bank list data or SEC mapping
 * Exchange information now comes from the bank-list.json generated by discover-banks.cjs
 * which uses authoritative exchange directories (NASDAQ, NYSE, OTC)
 */
function determineExchange(ticker, companyName, bankListEntry) {
  // If we have bank list data with exchange info, use it
  if (bankListEntry && bankListEntry.exchange) {
    return bankListEntry.exchange;
  }

  // Fallback: Try to determine from SEC ticker map
  if (tickerToCikMap) {
    const upperTicker = ticker?.toUpperCase();
    const mapping = tickerToCikMap[upperTicker];
    // SEC's company_tickers.json doesn't include exchange, so we can't help here
  }

  // Last resort fallback for banks not in the list
  // This shouldn't happen in normal operation if bank-list.json is up to date
  return 'N/A';
}

/**
 * Process a single bank
 *
 * New features included:
 * - Security type identification (common vs exchange-traded)
 * - Dividend metrics (TTM dividends, payout ratio)
 * - US vs Non-US classification
 *
 * @param {string} ticker - Stock ticker symbol
 * @param {number} index - Index in the bank list
 * @param {Object} bankListEntry - Optional bank list entry with CIK, exchange, SIC info
 */
async function processBank(ticker, index, bankListEntry = null) {
  console.log(`\n[${index}] Processing ${ticker}...`);

  try {
    // Get company info and CIK
    // If we have bank list entry with CIK, use it directly
    let companyInfo;
    if (bankListEntry && bankListEntry.cik) {
      companyInfo = {
        cik: bankListEntry.cik,
        name: bankListEntry.companyName
      };
      console.log(`  ✓ Using bank list: ${companyInfo.name} (CIK: ${companyInfo.cik})`);
    } else {
      companyInfo = await getCompanyInfo(ticker);
      console.log(`  ✓ Found: ${companyInfo.name} (CIK: ${companyInfo.cik})`);
    }

    // Fetch company facts from SEC (XBRL financial data)
    const companyFacts = await getCompanyFacts(companyInfo.cik);
    console.log(`  ✓ Fetched SEC EDGAR company facts`);

    // Fetch company submissions for country classification
    // This provides incorporation state/country and address information
    const companySubmissions = await getCompanySubmissions(companyInfo.cik);
    if (companySubmissions) {
      console.log(`  ✓ Fetched SEC EDGAR company submissions`);
    }

    // Determine security type (common vs exchange-traded)
    // Exchange-traded securities include preferred stock, debt securities
    const securityTypeInfo = determineSecurityType(ticker, companyFacts);
    console.log(`  ✓ Security type: ${securityTypeInfo.securityType} (${securityTypeInfo.reason})`);

    // Determine US vs Non-US classification
    const countryInfo = determineCountryClassification(companySubmissions);
    console.log(`  ✓ Country: ${countryInfo.country} (${countryInfo.confidence} confidence - ${countryInfo.reason})`);

    // Get prior close price from Marketstack
    // Marketstack counts each symbol as 1 API request toward monthly quota
    // Skip price fetch for exchange-traded securities (they need different handling)
    let currentPrice = null;
    if (!securityTypeInfo.isExchangeTraded) {
      await delay(500); // Small delay between price requests
      currentPrice = await getCurrentPrice(ticker);
      if (currentPrice) {
        console.log(`  ✓ Current price: $${currentPrice.toFixed(2)}`);
      }
    } else {
      console.log(`  ⚠ Skipping price fetch for exchange-traded security`);
    }

    // Calculate metrics (pass isExchangeTraded to null out price metrics)
    const metrics = calculateMetrics(companyFacts, currentPrice, securityTypeInfo.isExchangeTraded);
    console.log(`  ✓ Calculated metrics (TTM: ${metrics.ttmMethod})`);

    // Add asterisk to ticker if data is stale (before 2024)
    const displayTicker = metrics.isStale ? `${ticker}*` : ticker;

    if (metrics.isStale) {
      console.log(`  ⚠ Warning: Data is stale (last report: ${metrics.dataDate})`);
    }

    // Get exchange from bank list entry (authoritative source)
    const exchange = determineExchange(ticker, companyInfo.name, bankListEntry);

    // Include SIC information if available
    const sicInfo = bankListEntry ? {
      sic: bankListEntry.sic,
      sicDescription: bankListEntry.sicDescription,
      otcTier: bankListEntry.otcTier
    } : {};

    return {
      id: `bank-${index}`,
      cik: companyInfo.cik,
      ticker: displayTicker,
      bankName: companyInfo.name,
      exchange: exchange,
      ...sicInfo,
      // Security type classification
      securityType: securityTypeInfo.securityType,
      isExchangeTraded: securityTypeInfo.isExchangeTraded,
      // Country classification
      isUS: countryInfo.isUS,
      country: countryInfo.country,
      stateOfIncorporation: countryInfo.stateOfIncorporation || null,
      countryConfidence: countryInfo.confidence,
      // Financial metrics (including dividend metrics)
      ...metrics,
      updatedAt: new Date().toISOString()
    };

  } catch (error) {
    console.error(`  ✗ Error processing ${ticker}: ${error.message}`);
    return null;
  }
}

/**
 * Main function
 */
async function main() {
  console.log('========================================');
  console.log('SEC EDGAR Bank Data Fetcher');
  console.log('========================================\n');
  console.log(`Node version: ${process.version}`);
  console.log(`Working directory: ${process.cwd()}`);
  console.log(`User-Agent: ${CONFIG.edgarUserAgent}`);
  console.log(`Started: ${new Date().toISOString()}\n`);

  // Verify axios is loaded
  try {
    console.log(`Axios loaded: ${typeof axios}`);
  } catch (err) {
    console.error('ERROR: axios not available:', err.message);
    process.exit(1);
  }

  // Load bank list from generated file (SEC EDGAR + SIC based)
  const bankList = loadBankList();

  // Determine which banks to process
  let banksToProcess;
  let useBankList = false;

  if (bankList && bankList.length > 0) {
    banksToProcess = bankList;
    useBankList = true;
    console.log(`\nProcessing ${banksToProcess.length} banks from SEC EDGAR SIC-based discovery`);

    // Show breakdown by exchange
    const byExchange = {};
    bankList.forEach(b => {
      byExchange[b.exchange] = (byExchange[b.exchange] || 0) + 1;
    });
    console.log('By exchange:', Object.entries(byExchange).map(([e, c]) => `${e}: ${c}`).join(', '));
  } else {
    // Fallback to minimal ticker list
    banksToProcess = CONFIG.fallbackTickers.map(ticker => ({ ticker }));
    console.log(`\nUsing fallback ticker list: ${CONFIG.fallbackTickers.length} banks`);
    console.warn('Note: Run "node scripts/discover-banks.cjs" to generate complete bank list');
  }

  console.log(`\nBanks to process: ${banksToProcess.length}`);

  const results = [];
  const errors = [];

  // Process each bank sequentially
  for (let i = 0; i < banksToProcess.length; i++) {
    const bankEntry = banksToProcess[i];
    const ticker = bankEntry.ticker;

    // Pass the full bank entry if using bank list (includes CIK, exchange, SIC info)
    const bankData = await processBank(ticker, i, useBankList ? bankEntry : null);

    if (bankData) {
      results.push(bankData);
    } else {
      errors.push(ticker);
    }

    // Progress indicator every 10 banks
    if ((i + 1) % 10 === 0 || i === banksToProcess.length - 1) {
      console.log(`Progress: ${i + 1}/${banksToProcess.length}`);
    }
  }

  // Sort by market cap (descending)
  results.sort((a, b) => {
    if (!a.marketCap) return 1;
    if (!b.marketCap) return -1;
    return b.marketCap - a.marketCap;
  });

  // Save to JSON file (in public/ for Vite and GitHub Pages)
  const outputPath = path.join(__dirname, '..', 'public', 'data', 'banks.json');
  const outputDir = path.dirname(outputPath);

  console.log(`\nOutput path: ${outputPath}`);
  console.log(`Output directory: ${outputDir}`);

  // Create data directory if it doesn't exist
  try {
    if (!fs.existsSync(outputDir)) {
      console.log('Creating output directory...');
      fs.mkdirSync(outputDir, { recursive: true });
      console.log('✓ Directory created');
    } else {
      console.log('✓ Directory exists');
    }

    console.log('Writing JSON file...');
    fs.writeFileSync(outputPath, JSON.stringify(results, null, 2));
    console.log('✓ File written successfully');
  } catch (writeError) {
    console.error('ERROR writing output file:', writeError);
    throw writeError;
  }

  // Summary
  console.log('\n========================================');
  console.log('Summary');
  console.log('========================================');
  console.log(`Total banks in list: ${banksToProcess.length}`);
  console.log(`Successful: ${results.length}`);
  console.log(`Failed: ${errors.length}`);

  // Show exchange distribution in results
  const resultsByExchange = {};
  results.forEach(b => {
    resultsByExchange[b.exchange] = (resultsByExchange[b.exchange] || 0) + 1;
  });
  console.log(`\nResults by Exchange:`);
  for (const [exchange, count] of Object.entries(resultsByExchange).sort((a, b) => b[1] - a[1])) {
    console.log(`  ${exchange}: ${count}`);
  }

  if (errors.length > 0) {
    console.log(`\nFailed tickers: ${errors.join(', ')}`);
  }

  // Show stale data warnings
  const staleBanks = results.filter(b => b.isStale);
  if (staleBanks.length > 0) {
    console.log(`\n⚠ Stale Data Warning (${staleBanks.length} banks):`);
    console.log('The following banks have data from before 2024:');
    staleBanks.forEach(b => {
      console.log(`  - ${b.ticker} (${b.dataDate})`);
    });
    console.log('Note: Tickers marked with * indicate data not current');
  }

  // Show TTM calculation methods
  const ttmMethods = {};
  results.forEach(b => {
    const method = b.ttmMethod || 'unknown';
    ttmMethods[method] = (ttmMethods[method] || 0) + 1;
  });
  console.log(`\nTTM Calculation Methods:`);
  Object.entries(ttmMethods).forEach(([method, count]) => {
    console.log(`  - ${method}: ${count} banks`);
  });

  console.log(`\nOutput saved to: ${outputPath}`);
  console.log(`File size: ${fs.statSync(outputPath).size} bytes`);
  console.log(`Completed: ${new Date().toISOString()}`);
  console.log('========================================\n');

  // Exit successfully if we got at least some data
  // Only fail if ALL banks failed
  if (results.length === 0) {
    console.error('FATAL: No banks were processed successfully!');
    process.exit(1);
  } else {
    console.log(`✓ Success! Processed ${results.length}/${banksToProcess.length} banks`);
    process.exit(0);
  }
}

// Run main function
main().catch(error => {
  console.error('\n========================================');
  console.error('FATAL ERROR');
  console.error('========================================');
  console.error('Error message:', error.message);
  console.error('Error stack:', error.stack);
  console.error('========================================\n');
  process.exit(1);
});
