#!/usr/bin/env node
/**
 * Standalone SEC EDGAR Data Fetcher for GitHub Actions
 * Fetches bank financial data from SEC EDGAR API and saves to JSON file
 */

const axios = require('axios');
const fs = require('fs');
const path = require('path');

// Configuration
const CONFIG = {
  edgarUserAgent: process.env.EDGAR_USER_AGENT || 'Bank-Analyzer github-actions@example.com',
  requestDelay: 150, // 150ms = ~6 req/sec (under SEC's 10 req/sec limit)
  // Bank list is now loaded dynamically from bank-list.json (generated by discover-banks.cjs)
  // Falls back to a minimal set if the file doesn't exist yet
  fallbackTickers: ['JPM', 'BAC', 'WFC', 'C', 'USB', 'PNC']
};

/**
 * Load bank list from generated bank-list.json file
 * This file is produced by discover-banks.cjs which queries SEC EDGAR by SIC code
 */
function loadBankList() {
  const bankListPath = path.join(__dirname, '..', 'public', 'data', 'bank-list.json');

  try {
    if (fs.existsSync(bankListPath)) {
      const data = JSON.parse(fs.readFileSync(bankListPath, 'utf8'));
      const banks = data.banks || [];

      // Filter to only banks with tickers and valid exchanges (NYSE, NASDAQ, OTC)
      const validBanks = banks.filter(b =>
        b.ticker &&
        ['NYSE', 'NASDAQ', 'OTC'].includes(b.exchange)
      );

      console.log(`✓ Loaded ${validBanks.length} banks from bank-list.json`);
      console.log(`  Source: SEC EDGAR + SIC Classification`);
      console.log(`  Generated: ${data.metadata?.generatedAt || 'unknown'}`);

      return validBanks;
    } else {
      console.warn('Warning: bank-list.json not found, using fallback tickers');
      console.warn('Run "node scripts/discover-banks.cjs" to generate the bank list');
      return null;
    }
  } catch (error) {
    console.warn(`Warning: Could not load bank-list.json: ${error.message}`);
    return null;
  }
}

// Global cache for SEC ticker-to-CIK mapping
let tickerToCikMap = null;

// Delay helper
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

/**
 * Get prior close stock price from Marketstack API
 * Requires MARKETSTACK_API_KEY environment variable
 * Uses EOD (end-of-day) endpoint for prior close prices
 * Commercial use allowed on Professional plan ($49.99/mo) and above
 * @see https://marketstack.com/documentation
 */
async function getCurrentPrice(ticker) {
  const apiKey = process.env.MARKETSTACK_API_KEY;

  if (!apiKey) {
    console.warn(`  Warning: MARKETSTACK_API_KEY not set, skipping price fetch for ${ticker}`);
    return null;
  }

  try {
    // Using Marketstack EOD endpoint for prior close price
    const url = `http://api.marketstack.com/v1/eod/latest?access_key=${apiKey}&symbols=${ticker}`;
    const response = await axios.get(url, {
      timeout: 15000,
      headers: { 'User-Agent': 'Bank-Analyzer/1.0' }
    });

    // Check for API error
    if (response.data?.error) {
      console.warn(`  Warning: Marketstack API error for ${ticker}: ${response.data.error.message}`);
      return null;
    }

    // Extract close price from the first data entry
    const data = response.data?.data?.[0];
    const price = data?.close;
    return price ? parseFloat(price) : null;
  } catch (error) {
    console.warn(`  Warning: Could not fetch price for ${ticker}: ${error.message}`);
    return null;
  }
}

/**
 * Load SEC's ticker-to-CIK mapping (cached globally)
 */
async function loadTickerToCikMap() {
  if (tickerToCikMap) {
    return tickerToCikMap; // Return cached version
  }

  try {
    console.log('Loading SEC ticker-to-CIK mapping...');
    await delay(CONFIG.requestDelay);

    const response = await axios.get(
      'https://www.sec.gov/files/company_tickers.json',
      {
        headers: { 'User-Agent': CONFIG.edgarUserAgent },
        timeout: 30000
      }
    );

    // Convert array format to ticker-keyed map
    // SEC returns: { "0": { "cik_str": 320193, "ticker": "AAPL", "title": "Apple Inc." }, ... }
    tickerToCikMap = {};

    for (const key in response.data) {
      const company = response.data[key];
      if (company.ticker && company.cik_str) {
        // Store with uppercase ticker as key
        tickerToCikMap[company.ticker.toUpperCase()] = {
          cik: String(company.cik_str).padStart(10, '0'),
          name: company.title
        };
      }
    }

    console.log(`✓ Loaded ${Object.keys(tickerToCikMap).length} company mappings`);
    return tickerToCikMap;
  } catch (error) {
    throw new Error(`Failed to load ticker-to-CIK map: ${error.message}`);
  }
}

/**
 * Get company CIK and info from ticker
 */
async function getCompanyInfo(ticker) {
  try {
    // Load mapping if not already loaded
    const map = await loadTickerToCikMap();

    const upperTicker = ticker.toUpperCase();
    const company = map[upperTicker];

    if (!company) {
      throw new Error(`Ticker ${ticker} not found in SEC database`);
    }

    return {
      cik: company.cik,
      name: company.name
    };
  } catch (error) {
    throw new Error(`Failed to get company info: ${error.message}`);
  }
}

/**
 * Fetch company facts from SEC EDGAR
 */
async function getCompanyFacts(cik) {
  try {
    await delay(CONFIG.requestDelay);

    const paddedCik = cik.padStart(10, '0');
    const url = `https://data.sec.gov/api/xbrl/companyfacts/CIK${paddedCik}.json`;

    const response = await axios.get(url, {
      headers: { 'User-Agent': CONFIG.edgarUserAgent },
      timeout: 30000
    });

    return response.data;
  } catch (error) {
    throw new Error(`Failed to fetch company facts: ${error.message}`);
  }
}

/**
 * Get latest point-in-time value (for balance sheet items like Assets, Equity)
 */
function getLatestPointInTimeValue(companyFacts, concept, taxonomy = 'us-gaap') {
  try {
    const conceptData = companyFacts.facts?.[taxonomy]?.[concept];
    if (!conceptData) return null;

    const usdUnits = conceptData.units?.USD;
    if (!usdUnits || usdUnits.length === 0) return null;

    // Get most recent value (from either 10-K or 10-Q)
    const allData = usdUnits
      .filter(item => (item.form === '10-K' || item.form === '10-Q') && item.val && item.end)
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    if (allData.length > 0) {
      return {
        value: allData[0].val,
        date: allData[0].end,
        form: allData[0].form
      };
    }

    return null;
  } catch (error) {
    return null;
  }
}

/**
 * Get TTM (Trailing Twelve Months) value for period-based items like Net Income, EPS
 * Always starts from the most recent filing period (10-K or 10-Q) to show the most current data.
 *
 * Logic:
 * - If most recent filing is a 10-K: Use it directly (it's already a full year / TTM)
 * - If most recent filing is a 10-Q: Calculate TTM by summing the last 4 quarters
 *   - Q1, Q2, Q3 come from 10-Q filings
 *   - Q4 is derived from: Annual (10-K) value - Q1 - Q2 - Q3 of that fiscal year
 */
function getTTMValue(companyFacts, concept, taxonomy = 'us-gaap') {
  try {
    const conceptData = companyFacts.facts?.[taxonomy]?.[concept];
    if (!conceptData) return null;

    const usdUnits = conceptData.units?.USD;
    if (!usdUnits || usdUnits.length === 0) return null;

    // Get all annual data (10-K filings)
    const annualData = usdUnits
      .filter(item => item.form === '10-K' && item.val !== undefined && item.val !== null && item.end && item.fy)
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    // Get all quarterly data (10-Q filings with Q1, Q2, Q3 periods)
    const quarterlyData = usdUnits
      .filter(item =>
        item.form === '10-Q' &&
        item.val !== undefined && item.val !== null &&
        item.end &&
        item.fy &&
        item.fp &&
        ['Q1', 'Q2', 'Q3'].includes(item.fp) // Only Q1-Q3 from 10-Q filings
      )
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    // Determine the most recent filing date
    const mostRecentAnnualDate = annualData.length > 0 ? new Date(annualData[0].end) : null;
    const mostRecentQuarterlyDate = quarterlyData.length > 0 ? new Date(quarterlyData[0].end) : null;

    // Case 1: No data at all
    if (!mostRecentAnnualDate && !mostRecentQuarterlyDate) {
      return null;
    }

    // Case 2: Only annual data available, or 10-K is more recent than any 10-Q
    if (mostRecentAnnualDate && (!mostRecentQuarterlyDate || mostRecentAnnualDate >= mostRecentQuarterlyDate)) {
      return {
        value: annualData[0].val,
        date: annualData[0].end,
        form: '10-K',
        method: 'annual'
      };
    }

    // Case 3: 10-Q is more recent - calculate TTM from quarters
    // We need to build a list of all quarters including derived Q4 values

    // Build a map of quarterly values by fiscal year and period
    const quarterMap = new Map(); // Key: "YYYY-Q#", Value: { value, end, fy, fp, source }

    // Add Q1, Q2, Q3 from 10-Q filings
    for (const q of quarterlyData) {
      const key = `${q.fy}-${q.fp}`;
      if (!quarterMap.has(key)) {
        quarterMap.set(key, {
          value: q.val,
          end: q.end,
          fy: q.fy,
          fp: q.fp,
          source: '10-Q'
        });
      }
    }

    // Derive Q4 values from annual data
    // Q4 = Annual - Q1 - Q2 - Q3 for the same fiscal year
    for (const annual of annualData) {
      const fy = annual.fy;
      const q1Key = `${fy}-Q1`;
      const q2Key = `${fy}-Q2`;
      const q3Key = `${fy}-Q3`;
      const q4Key = `${fy}-Q4`;

      // Only derive Q4 if we don't already have it and have the annual value
      if (!quarterMap.has(q4Key)) {
        const q1 = quarterMap.get(q1Key);
        const q2 = quarterMap.get(q2Key);
        const q3 = quarterMap.get(q3Key);

        if (q1 && q2 && q3) {
          // Derive Q4 from annual minus Q1-Q3
          const q4Value = annual.val - q1.value - q2.value - q3.value;
          quarterMap.set(q4Key, {
            value: q4Value,
            end: annual.end, // Use annual end date for Q4
            fy: fy,
            fp: 'Q4',
            source: 'derived'
          });
        } else {
          // If we don't have all quarters, use the annual value as Q4 approximation
          // This handles cases where we might be missing some Q data
          quarterMap.set(q4Key, {
            value: annual.val, // Use full annual as placeholder (not ideal but better than nothing)
            end: annual.end,
            fy: fy,
            fp: 'Q4',
            source: '10-K-fallback'
          });
        }
      }
    }

    // Convert map to sorted array (most recent first)
    const allQuarters = Array.from(quarterMap.values())
      .sort((a, b) => new Date(b.end) - new Date(a.end));

    if (allQuarters.length >= 4) {
      // Sum the last 4 quarters to get TTM
      const last4Quarters = allQuarters.slice(0, 4);
      const ttmValue = last4Quarters.reduce((sum, q) => sum + q.value, 0);

      return {
        value: ttmValue,
        date: last4Quarters[0].end, // Most recent quarter end date
        form: '10-Q',
        method: 'sum-4Q',
        quarters: last4Quarters.map(q => ({
          end: q.end,
          period: q.fp,
          value: q.value,
          source: q.source
        }))
      };
    }

    // Fallback: If we have the most recent annual data, use it
    if (annualData.length > 0) {
      console.warn(`  Warning: Using annual data as fallback for ${concept} (insufficient quarterly data)`);
      return {
        value: annualData[0].val,
        date: annualData[0].end,
        form: '10-K',
        method: 'annual-fallback'
      };
    }

    // Last resort: Use whatever quarterly data we have
    if (allQuarters.length > 0) {
      console.warn(`  Warning: Using partial quarterly data for ${concept} (only ${allQuarters.length} quarters available)`);
      const partialTTM = allQuarters.reduce((sum, q) => sum + q.value, 0);
      return {
        value: partialTTM,
        date: allQuarters[0].end,
        form: '10-Q',
        method: `partial-${allQuarters.length}Q`,
        quarters: allQuarters.map(q => ({
          end: q.end,
          period: q.fp,
          value: q.value,
          source: q.source
        }))
      };
    }

    return null;
  } catch (error) {
    return null;
  }
}

/**
 * Calculate all banking metrics using TTM for period-based items
 */
function calculateMetrics(companyFacts, currentPrice) {
  // Balance sheet items (point-in-time) - use latest value
  const totalAssets = getLatestPointInTimeValue(companyFacts, 'Assets');
  const totalEquity = getLatestPointInTimeValue(companyFacts, 'StockholdersEquity') ||
                      getLatestPointInTimeValue(companyFacts, 'StockholdersEquityIncludingPortionAttributableToNoncontrollingInterest');
  const sharesOutstanding = getLatestPointInTimeValue(companyFacts, 'CommonStockSharesOutstanding') ||
                            getLatestPointInTimeValue(companyFacts, 'WeightedAverageNumberOfSharesOutstandingBasic');
  const goodwill = getLatestPointInTimeValue(companyFacts, 'Goodwill');
  const intangibleAssets = getLatestPointInTimeValue(companyFacts, 'IntangibleAssetsNetExcludingGoodwill');

  // Income statement items (period-based) - use TTM
  const netIncome = getTTMValue(companyFacts, 'NetIncomeLoss') ||
                    getTTMValue(companyFacts, 'ProfitLoss') ||
                    getTTMValue(companyFacts, 'NetIncomeLossAvailableToCommonStockholdersBasic');
  const eps = getTTMValue(companyFacts, 'EarningsPerShareBasic') ||
              getTTMValue(companyFacts, 'EarningsPerShareDiluted');

  // Determine most recent data date
  const dataDate = netIncome?.date || totalEquity?.date || totalAssets?.date;

  // Check if data is stale (before 2024)
  const isStale = dataDate ? new Date(dataDate) < new Date('2024-01-01') : false;

  // Log TTM calculation method for debugging
  if (netIncome?.method) {
    console.log(`  Net Income TTM: ${netIncome.method} (${netIncome.form}) as of ${netIncome.date}`);
    if (netIncome.quarters && netIncome.quarters.length > 0) {
      console.log(`    Quarters used: ${netIncome.quarters.map(q => `${q.period}(${q.source})`).join(', ')}`);
    }
  }
  if (eps?.method) {
    console.log(`  EPS TTM: ${eps.method} (${eps.form}) as of ${eps.date}`);
  }

  // Calculate derived values
  const tangibleBookValue = totalEquity?.value ?
    totalEquity.value - (goodwill?.value || 0) - (intangibleAssets?.value || 0) : null;

  const marketCap = currentPrice && sharesOutstanding?.value ?
    currentPrice * sharesOutstanding.value : null;

  const bookValuePerShare = totalEquity?.value && sharesOutstanding?.value ?
    totalEquity.value / sharesOutstanding.value : null;

  const tangibleBookValuePerShare = tangibleBookValue && sharesOutstanding?.value ?
    tangibleBookValue / sharesOutstanding.value : null;

  // Calculate ratios
  const pni = marketCap && netIncome?.value && netIncome.value > 0 ?
    marketCap / netIncome.value : null;

  const ptbvps = currentPrice && tangibleBookValuePerShare && tangibleBookValuePerShare > 0 ?
    currentPrice / tangibleBookValuePerShare : null;

  const mktCapSE = marketCap && totalEquity?.value && totalEquity.value > 0 ?
    marketCap / totalEquity.value : null;

  const niTBV = netIncome?.value && tangibleBookValue && tangibleBookValue > 0 ?
    netIncome.value / tangibleBookValue : null;

  const roe = netIncome?.value && totalEquity?.value && totalEquity.value > 0 ?
    (netIncome.value / totalEquity.value) * 100 : null;

  const rota = netIncome?.value && totalAssets?.value && totalAssets.value > 0 ?
    (netIncome.value / totalAssets.value) * 100 : null;

  // Graham metrics
  const grahamNumber = eps?.value && bookValuePerShare && eps.value > 0 && bookValuePerShare > 0 ?
    Math.sqrt(22.5 * eps.value * bookValuePerShare) : null;

  const grahamMoS = grahamNumber && currentPrice ?
    grahamNumber - currentPrice : null;

  const grahamMoSPct = grahamNumber && currentPrice && currentPrice > 0 ?
    ((grahamNumber - currentPrice) / currentPrice) * 100 : null;

  return {
    price: currentPrice,
    marketCap: marketCap ? marketCap / 1000000 : null, // Convert to millions
    pni: pni ? parseFloat(pni.toFixed(4)) : null,
    ptbvps: ptbvps ? parseFloat(ptbvps.toFixed(4)) : null,
    mktCapSE: mktCapSE ? parseFloat(mktCapSE.toFixed(4)) : null,
    niTBV: niTBV ? parseFloat(niTBV.toFixed(4)) : null,
    roe: roe ? parseFloat(roe.toFixed(4)) : null,
    rota: rota ? parseFloat(rota.toFixed(4)) : null,
    grahamNum: grahamNumber ? parseFloat(grahamNumber.toFixed(4)) : null,
    grahamMoS: grahamMoS ? parseFloat(grahamMoS.toFixed(4)) : null,
    grahamMoSPct: grahamMoSPct ? parseFloat(grahamMoSPct.toFixed(4)) : null,
    dataDate: dataDate,
    isStale: isStale, // Flag if data is before 2024
    ttmMethod: netIncome?.method || 'unknown' // Track how TTM was calculated
  };
}

/**
 * Determine exchange from bank list data or SEC mapping
 * Exchange information now comes from the bank-list.json generated by discover-banks.cjs
 * which uses authoritative exchange directories (NASDAQ, NYSE, OTC)
 */
function determineExchange(ticker, companyName, bankListEntry) {
  // If we have bank list data with exchange info, use it
  if (bankListEntry && bankListEntry.exchange) {
    return bankListEntry.exchange;
  }

  // Fallback: Try to determine from SEC ticker map
  if (tickerToCikMap) {
    const upperTicker = ticker?.toUpperCase();
    const mapping = tickerToCikMap[upperTicker];
    // SEC's company_tickers.json doesn't include exchange, so we can't help here
  }

  // Last resort fallback for banks not in the list
  // This shouldn't happen in normal operation if bank-list.json is up to date
  return 'N/A';
}

/**
 * Process a single bank
 * @param {string} ticker - Stock ticker symbol
 * @param {number} index - Index in the bank list
 * @param {Object} bankListEntry - Optional bank list entry with CIK, exchange, SIC info
 */
async function processBank(ticker, index, bankListEntry = null) {
  console.log(`\n[${index}] Processing ${ticker}...`);

  try {
    // Get company info and CIK
    // If we have bank list entry with CIK, use it directly
    let companyInfo;
    if (bankListEntry && bankListEntry.cik) {
      companyInfo = {
        cik: bankListEntry.cik,
        name: bankListEntry.companyName
      };
      console.log(`  ✓ Using bank list: ${companyInfo.name} (CIK: ${companyInfo.cik})`);
    } else {
      companyInfo = await getCompanyInfo(ticker);
      console.log(`  ✓ Found: ${companyInfo.name} (CIK: ${companyInfo.cik})`);
    }

    // Fetch company facts from SEC
    const companyFacts = await getCompanyFacts(companyInfo.cik);
    console.log(`  ✓ Fetched SEC EDGAR data`);

    // Get prior close price from Marketstack
    // Marketstack counts each symbol as 1 API request toward monthly quota
    await delay(500); // Small delay between price requests
    const currentPrice = await getCurrentPrice(ticker);
    if (currentPrice) {
      console.log(`  ✓ Current price: $${currentPrice.toFixed(2)}`);
    }

    // Calculate metrics
    const metrics = calculateMetrics(companyFacts, currentPrice);
    console.log(`  ✓ Calculated metrics (TTM: ${metrics.ttmMethod})`);

    // Add asterisk to ticker if data is stale (before 2024)
    const displayTicker = metrics.isStale ? `${ticker}*` : ticker;

    if (metrics.isStale) {
      console.log(`  ⚠ Warning: Data is stale (last report: ${metrics.dataDate})`);
    }

    // Get exchange from bank list entry (authoritative source)
    const exchange = determineExchange(ticker, companyInfo.name, bankListEntry);

    // Include SIC information if available
    const sicInfo = bankListEntry ? {
      sic: bankListEntry.sic,
      sicDescription: bankListEntry.sicDescription,
      otcTier: bankListEntry.otcTier
    } : {};

    return {
      id: `bank-${index}`,
      cik: companyInfo.cik,
      ticker: displayTicker,
      bankName: companyInfo.name,
      exchange: exchange,
      ...sicInfo,
      ...metrics,
      updatedAt: new Date().toISOString()
    };

  } catch (error) {
    console.error(`  ✗ Error processing ${ticker}: ${error.message}`);
    return null;
  }
}

/**
 * Main function
 */
async function main() {
  console.log('========================================');
  console.log('SEC EDGAR Bank Data Fetcher');
  console.log('========================================\n');
  console.log(`Node version: ${process.version}`);
  console.log(`Working directory: ${process.cwd()}`);
  console.log(`User-Agent: ${CONFIG.edgarUserAgent}`);
  console.log(`Started: ${new Date().toISOString()}\n`);

  // Verify axios is loaded
  try {
    console.log(`Axios loaded: ${typeof axios}`);
  } catch (err) {
    console.error('ERROR: axios not available:', err.message);
    process.exit(1);
  }

  // Load bank list from generated file (SEC EDGAR + SIC based)
  const bankList = loadBankList();

  // Determine which banks to process
  let banksToProcess;
  let useBankList = false;

  if (bankList && bankList.length > 0) {
    banksToProcess = bankList;
    useBankList = true;
    console.log(`\nProcessing ${banksToProcess.length} banks from SEC EDGAR SIC-based discovery`);

    // Show breakdown by exchange
    const byExchange = {};
    bankList.forEach(b => {
      byExchange[b.exchange] = (byExchange[b.exchange] || 0) + 1;
    });
    console.log('By exchange:', Object.entries(byExchange).map(([e, c]) => `${e}: ${c}`).join(', '));
  } else {
    // Fallback to minimal ticker list
    banksToProcess = CONFIG.fallbackTickers.map(ticker => ({ ticker }));
    console.log(`\nUsing fallback ticker list: ${CONFIG.fallbackTickers.length} banks`);
    console.warn('Note: Run "node scripts/discover-banks.cjs" to generate complete bank list');
  }

  console.log(`\nBanks to process: ${banksToProcess.length}`);

  const results = [];
  const errors = [];

  // Process each bank sequentially
  for (let i = 0; i < banksToProcess.length; i++) {
    const bankEntry = banksToProcess[i];
    const ticker = bankEntry.ticker;

    // Pass the full bank entry if using bank list (includes CIK, exchange, SIC info)
    const bankData = await processBank(ticker, i, useBankList ? bankEntry : null);

    if (bankData) {
      results.push(bankData);
    } else {
      errors.push(ticker);
    }

    // Progress indicator every 10 banks
    if ((i + 1) % 10 === 0 || i === banksToProcess.length - 1) {
      console.log(`Progress: ${i + 1}/${banksToProcess.length}`);
    }
  }

  // Sort by market cap (descending)
  results.sort((a, b) => {
    if (!a.marketCap) return 1;
    if (!b.marketCap) return -1;
    return b.marketCap - a.marketCap;
  });

  // Save to JSON file (in public/ for Vite and GitHub Pages)
  const outputPath = path.join(__dirname, '..', 'public', 'data', 'banks.json');
  const outputDir = path.dirname(outputPath);

  console.log(`\nOutput path: ${outputPath}`);
  console.log(`Output directory: ${outputDir}`);

  // Create data directory if it doesn't exist
  try {
    if (!fs.existsSync(outputDir)) {
      console.log('Creating output directory...');
      fs.mkdirSync(outputDir, { recursive: true });
      console.log('✓ Directory created');
    } else {
      console.log('✓ Directory exists');
    }

    console.log('Writing JSON file...');
    fs.writeFileSync(outputPath, JSON.stringify(results, null, 2));
    console.log('✓ File written successfully');
  } catch (writeError) {
    console.error('ERROR writing output file:', writeError);
    throw writeError;
  }

  // Summary
  console.log('\n========================================');
  console.log('Summary');
  console.log('========================================');
  console.log(`Total banks in list: ${banksToProcess.length}`);
  console.log(`Successful: ${results.length}`);
  console.log(`Failed: ${errors.length}`);

  // Show exchange distribution in results
  const resultsByExchange = {};
  results.forEach(b => {
    resultsByExchange[b.exchange] = (resultsByExchange[b.exchange] || 0) + 1;
  });
  console.log(`\nResults by Exchange:`);
  for (const [exchange, count] of Object.entries(resultsByExchange).sort((a, b) => b[1] - a[1])) {
    console.log(`  ${exchange}: ${count}`);
  }

  if (errors.length > 0) {
    console.log(`\nFailed tickers: ${errors.join(', ')}`);
  }

  // Show stale data warnings
  const staleBanks = results.filter(b => b.isStale);
  if (staleBanks.length > 0) {
    console.log(`\n⚠ Stale Data Warning (${staleBanks.length} banks):`);
    console.log('The following banks have data from before 2024:');
    staleBanks.forEach(b => {
      console.log(`  - ${b.ticker} (${b.dataDate})`);
    });
    console.log('Note: Tickers marked with * indicate data not current');
  }

  // Show TTM calculation methods
  const ttmMethods = {};
  results.forEach(b => {
    const method = b.ttmMethod || 'unknown';
    ttmMethods[method] = (ttmMethods[method] || 0) + 1;
  });
  console.log(`\nTTM Calculation Methods:`);
  Object.entries(ttmMethods).forEach(([method, count]) => {
    console.log(`  - ${method}: ${count} banks`);
  });

  console.log(`\nOutput saved to: ${outputPath}`);
  console.log(`File size: ${fs.statSync(outputPath).size} bytes`);
  console.log(`Completed: ${new Date().toISOString()}`);
  console.log('========================================\n');

  // Exit successfully if we got at least some data
  // Only fail if ALL banks failed
  if (results.length === 0) {
    console.error('FATAL: No banks were processed successfully!');
    process.exit(1);
  } else {
    console.log(`✓ Success! Processed ${results.length}/${banksToProcess.length} banks`);
    process.exit(0);
  }
}

// Run main function
main().catch(error => {
  console.error('\n========================================');
  console.error('FATAL ERROR');
  console.error('========================================');
  console.error('Error message:', error.message);
  console.error('Error stack:', error.stack);
  console.error('========================================\n');
  process.exit(1);
});
